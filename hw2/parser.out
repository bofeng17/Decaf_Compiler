Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> program class_decl
Rule 2     program -> empty
Rule 3     class_decl -> CLASS ID { class_body_decls }
Rule 4     class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls }
Rule 5     class_body_decls -> class_body_decls class_body_decl
Rule 6     class_body_decls -> class_body_decl
Rule 7     class_body_decl -> field_decl
Rule 8     class_body_decl -> method_decl
Rule 9     class_body_decl -> constructor_decl
Rule 10    field_decl -> modifier var_decl
Rule 11    modifier -> access class_member
Rule 12    access -> PUBLIC
Rule 13    access -> PRIVATE
Rule 14    access -> empty
Rule 15    class_member -> STATIC
Rule 16    class_member -> empty
Rule 17    var_decl -> type variables
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variables -> variables , variable
Rule 23    variables -> variable
Rule 24    variable -> variable [ ]
Rule 25    variable -> ID
Rule 26    method_decl -> modifier ( all_type ) ID ( formals ) block
Rule 27    method_decl -> modifier ( all_type ) ID ( ) block
Rule 28    all_type -> type
Rule 29    all_type -> VOID
Rule 30    constructor_decl -> modifier ID ( formals ) block
Rule 31    constructor_decl -> modifier ID ( ) block
Rule 32    formals -> formals , formal_param
Rule 33    formals -> formal_param
Rule 34    formal_param -> type variable
Rule 35    block -> { stmts }
Rule 36    stmts -> stmts stmt
Rule 37    stmts -> empty
Rule 38    stmt -> IF ( expr ) stmt
Rule 39    stmt -> IF ( expr ) stmt ELSE stmt
Rule 40    stmt -> WHILE ( expr ) stmt
Rule 41    stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt
Rule 42    stmt -> RETURN exprs
Rule 43    stmt -> stmt_expr
Rule 44    stmt -> BREAK
Rule 45    stmt -> CONTINUE
Rule 46    stmt -> block
Rule 47    stmt -> var_decl
Rule 48    exprs -> exprs expr
Rule 49    exprs -> expr
Rule 50    literal -> INT_CONST
Rule 51    literal -> FLOAT_CONST
Rule 52    literal -> STRING_CONST
Rule 53    literal -> NULL
Rule 54    literal -> TRUE
Rule 55    literal -> FALSE
Rule 56    primary -> literal
Rule 57    primary -> THIS
Rule 58    primary -> SUPER
Rule 59    primary -> ( expr )
Rule 60    primary -> NEW ID ( have_arguments )
Rule 61    primary -> lhs
Rule 62    primary -> method_invocation
Rule 63    have_arguments -> arguments
Rule 64    have_arguments -> empty
Rule 65    arguments -> arguments , expr
Rule 66    arguments -> expr
Rule 67    lhs -> field_access
Rule 68    lhs -> array_access
Rule 69    field_access -> primary . ID
Rule 70    field_access -> ID
Rule 71    array_access -> primary [ expr ]
Rule 72    method_invocation -> field_access ( have_arguments )
Rule 73    expr -> primary
Rule 74    expr -> assign
Rule 75    expr -> new_array
Rule 76    expr -> expr arith_op expr
Rule 77    expr -> expr bool_op expr
Rule 78    expr -> unary_op expr
Rule 79    assign -> lhs = expr
Rule 80    assign -> lhs INC
Rule 81    assign -> INC lhs
Rule 82    assign -> lhs DEC
Rule 83    assign -> DEC lhs
Rule 84    new_array -> new_array [ ]
Rule 85    new_array -> new_array_temp
Rule 86    new_array_temp -> new_array_temp [ expr ]
Rule 87    new_array_temp -> NEW type [ expr ]
Rule 88    arith_op -> +
Rule 89    arith_op -> -
Rule 90    arith_op -> *
Rule 91    arith_op -> /
Rule 92    bool_op -> AND
Rule 93    bool_op -> OR
Rule 94    bool_op -> EQL
Rule 95    bool_op -> UNEQL
Rule 96    bool_op -> <
Rule 97    bool_op -> >
Rule 98    bool_op -> LE
Rule 99    bool_op -> GE
Rule 100   unary_op -> +
Rule 101   unary_op -> -
Rule 102   unary_op -> !
Rule 103   stmt_expr -> assign
Rule 104   stmt_expr -> method_invocation
Rule 105   empty -> <empty>

Terminals, with rules where they appear

!                    : 102
(                    : 4 26 26 27 27 30 31 38 39 40 41 59 60 72
)                    : 4 26 26 27 27 30 31 38 39 40 41 59 60 72
*                    : 90
+                    : 88 100
,                    : 22 32 65
-                    : 89 101
.                    : 69
/                    : 91
;                    : 41 41
<                    : 96
=                    : 79
>                    : 97
AND                  : 92
BOOLEAN              : 20
BREAK                : 44
CLASS                : 3 4
CONTINUE             : 45
DEC                  : 82 83
DO                   : 
ELSE                 : 39
EQL                  : 94
EXTENDS              : 4
FALSE                : 55
FLOAT                : 19
FLOAT_CONST          : 51
FOR                  : 41
GE                   : 99
ID                   : 3 4 4 21 25 26 27 30 31 60 69 70
IF                   : 38 39
INC                  : 80 81
INT                  : 18
INT_CONST            : 50
LE                   : 98
NEW                  : 60 87
NULL                 : 53
OR                   : 93
PRIVATE              : 13
PUBLIC               : 12
RETURN               : 42
STATIC               : 15
STRING_CONST         : 52
SUPER                : 58
THIS                 : 57
TRUE                 : 54
UNEQL                : 95
VOID                 : 29
WHILE                : 40
[                    : 24 71 84 86 87
]                    : 24 71 84 86 87
error                : 
{                    : 3 4 35
}                    : 3 4 35

Nonterminals, with rules where they appear

access               : 11
all_type             : 26 27
arguments            : 63 65
arith_op             : 76
array_access         : 68
assign               : 74 103
block                : 26 27 30 31 46
bool_op              : 77
class_body_decl      : 5 6
class_body_decls     : 3 4 5
class_decl           : 1
class_member         : 11
constructor_decl     : 9
empty                : 2 14 16 37 64
expr                 : 38 39 40 41 48 49 59 65 66 71 76 76 77 77 78 79 86 87
exprs                : 42 48
field_access         : 67 72
field_decl           : 7
formal_param         : 32 33
formals              : 26 30 32
have_arguments       : 60 72
lhs                  : 61 79 80 81 82 83
literal              : 56
method_decl          : 8
method_invocation    : 62 104
modifier             : 10 26 27 30 31
new_array            : 75 84
new_array_temp       : 85 86
primary              : 69 71 73
program              : 1 0
stmt                 : 36 38 39 39 40 41
stmt_expr            : 41 41 43
stmts                : 35 36
type                 : 17 28 34 87
unary_op             : 78
var_decl             : 10 47
variable             : 22 23 24 34
variables            : 17 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program class_decl
    (2) program -> . empty
    (105) empty -> .

    CLASS           reduce using rule 105 (empty -> .)
    $end            reduce using rule 105 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (1) program -> program . class_decl
    (3) class_decl -> . CLASS ID { class_body_decls }
    (4) class_decl -> . CLASS ID ( EXTENDS ID ) { class_body_decls }

    CLASS           shift and go to state 3

    class_decl                     shift and go to state 4

state 2

    (2) program -> empty .

    CLASS           reduce using rule 2 (program -> empty .)
    $end            reduce using rule 2 (program -> empty .)


state 3

    (3) class_decl -> CLASS . ID { class_body_decls }
    (4) class_decl -> CLASS . ID ( EXTENDS ID ) { class_body_decls }

    ID              shift and go to state 5


state 4

    (1) program -> program class_decl .

    CLASS           reduce using rule 1 (program -> program class_decl .)
    $end            reduce using rule 1 (program -> program class_decl .)


state 5

    (3) class_decl -> CLASS ID . { class_body_decls }
    (4) class_decl -> CLASS ID . ( EXTENDS ID ) { class_body_decls }

    {               shift and go to state 7
    (               shift and go to state 6


state 6

    (4) class_decl -> CLASS ID ( . EXTENDS ID ) { class_body_decls }

    EXTENDS         shift and go to state 8


state 7

    (3) class_decl -> CLASS ID { . class_body_decls }
    (5) class_body_decls -> . class_body_decls class_body_decl
    (6) class_body_decls -> . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (105) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)

    class_body_decl                shift and go to state 9
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17
    class_body_decls               shift and go to state 18

state 8

    (4) class_decl -> CLASS ID ( EXTENDS . ID ) { class_body_decls }

    ID              shift and go to state 19


state 9

    (6) class_body_decls -> class_body_decl .

    }               reduce using rule 6 (class_body_decls -> class_body_decl .)
    PUBLIC          reduce using rule 6 (class_body_decls -> class_body_decl .)
    PRIVATE         reduce using rule 6 (class_body_decls -> class_body_decl .)
    (               reduce using rule 6 (class_body_decls -> class_body_decl .)
    ID              reduce using rule 6 (class_body_decls -> class_body_decl .)
    INT             reduce using rule 6 (class_body_decls -> class_body_decl .)
    FLOAT           reduce using rule 6 (class_body_decls -> class_body_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decls -> class_body_decl .)
    STATIC          reduce using rule 6 (class_body_decls -> class_body_decl .)


state 10

    (13) access -> PRIVATE .

    STATIC          reduce using rule 13 (access -> PRIVATE .)
    (               reduce using rule 13 (access -> PRIVATE .)
    ID              reduce using rule 13 (access -> PRIVATE .)
    INT             reduce using rule 13 (access -> PRIVATE .)
    FLOAT           reduce using rule 13 (access -> PRIVATE .)
    BOOLEAN         reduce using rule 13 (access -> PRIVATE .)


state 11

    (7) class_body_decl -> field_decl .

    }               reduce using rule 7 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 7 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> field_decl .)
    (               reduce using rule 7 (class_body_decl -> field_decl .)
    ID              reduce using rule 7 (class_body_decl -> field_decl .)
    INT             reduce using rule 7 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> field_decl .)


state 12

    (9) class_body_decl -> constructor_decl .

    }               reduce using rule 9 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> constructor_decl .)
    (               reduce using rule 9 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 9 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 9 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> constructor_decl .)


state 13

    (8) class_body_decl -> method_decl .

    }               reduce using rule 8 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl -> method_decl .)
    (               reduce using rule 8 (class_body_decl -> method_decl .)
    ID              reduce using rule 8 (class_body_decl -> method_decl .)
    INT             reduce using rule 8 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 8 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 8 (class_body_decl -> method_decl .)


state 14

    (11) modifier -> access . class_member
    (15) class_member -> . STATIC
    (16) class_member -> . empty
    (105) empty -> .

    STATIC          shift and go to state 20
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)

    class_member                   shift and go to state 21
    empty                          shift and go to state 22

state 15

    (14) access -> empty .

    STATIC          reduce using rule 14 (access -> empty .)
    (               reduce using rule 14 (access -> empty .)
    ID              reduce using rule 14 (access -> empty .)
    INT             reduce using rule 14 (access -> empty .)
    FLOAT           reduce using rule 14 (access -> empty .)
    BOOLEAN         reduce using rule 14 (access -> empty .)


state 16

    (12) access -> PUBLIC .

    STATIC          reduce using rule 12 (access -> PUBLIC .)
    (               reduce using rule 12 (access -> PUBLIC .)
    ID              reduce using rule 12 (access -> PUBLIC .)
    INT             reduce using rule 12 (access -> PUBLIC .)
    FLOAT           reduce using rule 12 (access -> PUBLIC .)
    BOOLEAN         reduce using rule 12 (access -> PUBLIC .)


state 17

    (10) field_decl -> modifier . var_decl
    (26) method_decl -> modifier . ( all_type ) ID ( formals ) block
    (27) method_decl -> modifier . ( all_type ) ID ( ) block
    (30) constructor_decl -> modifier . ID ( formals ) block
    (31) constructor_decl -> modifier . ID ( ) block
    (17) var_decl -> . type variables
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    (               shift and go to state 23
    ID              shift and go to state 29
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27

    var_decl                       shift and go to state 25
    type                           shift and go to state 28

state 18

    (3) class_decl -> CLASS ID { class_body_decls . }
    (5) class_body_decls -> class_body_decls . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (105) empty -> .

    }               shift and go to state 31
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)

    class_body_decl                shift and go to state 30
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17

state 19

    (4) class_decl -> CLASS ID ( EXTENDS ID . ) { class_body_decls }

    )               shift and go to state 32


state 20

    (15) class_member -> STATIC .

    (               reduce using rule 15 (class_member -> STATIC .)
    ID              reduce using rule 15 (class_member -> STATIC .)
    INT             reduce using rule 15 (class_member -> STATIC .)
    FLOAT           reduce using rule 15 (class_member -> STATIC .)
    BOOLEAN         reduce using rule 15 (class_member -> STATIC .)


state 21

    (11) modifier -> access class_member .

    (               reduce using rule 11 (modifier -> access class_member .)
    ID              reduce using rule 11 (modifier -> access class_member .)
    INT             reduce using rule 11 (modifier -> access class_member .)
    FLOAT           reduce using rule 11 (modifier -> access class_member .)
    BOOLEAN         reduce using rule 11 (modifier -> access class_member .)


state 22

    (16) class_member -> empty .

    (               reduce using rule 16 (class_member -> empty .)
    ID              reduce using rule 16 (class_member -> empty .)
    INT             reduce using rule 16 (class_member -> empty .)
    FLOAT           reduce using rule 16 (class_member -> empty .)
    BOOLEAN         reduce using rule 16 (class_member -> empty .)


state 23

    (26) method_decl -> modifier ( . all_type ) ID ( formals ) block
    (27) method_decl -> modifier ( . all_type ) ID ( ) block
    (28) all_type -> . type
    (29) all_type -> . VOID
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 33
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    type                           shift and go to state 34
    all_type                       shift and go to state 35

state 24

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)
    )               reduce using rule 19 (type -> FLOAT .)
    [               reduce using rule 19 (type -> FLOAT .)


state 25

    (10) field_decl -> modifier var_decl .

    }               reduce using rule 10 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 10 (field_decl -> modifier var_decl .)
    (               reduce using rule 10 (field_decl -> modifier var_decl .)
    ID              reduce using rule 10 (field_decl -> modifier var_decl .)
    INT             reduce using rule 10 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 10 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 10 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 10 (field_decl -> modifier var_decl .)


state 26

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)
    )               reduce using rule 18 (type -> INT .)
    [               reduce using rule 18 (type -> INT .)


state 27

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)
    )               reduce using rule 20 (type -> BOOLEAN .)
    [               reduce using rule 20 (type -> BOOLEAN .)


state 28

    (17) var_decl -> type . variables
    (22) variables -> . variables , variable
    (23) variables -> . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 38
    variables                      shift and go to state 37

state 29

    (30) constructor_decl -> modifier ID . ( formals ) block
    (31) constructor_decl -> modifier ID . ( ) block
    (21) type -> ID .

    (               shift and go to state 40
    ID              reduce using rule 21 (type -> ID .)


state 30

    (5) class_body_decls -> class_body_decls class_body_decl .

    }               reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    PUBLIC          reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    PRIVATE         reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    (               reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    ID              reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    INT             reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    FLOAT           reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    BOOLEAN         reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    STATIC          reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)


state 31

    (3) class_decl -> CLASS ID { class_body_decls } .

    CLASS           reduce using rule 3 (class_decl -> CLASS ID { class_body_decls } .)
    $end            reduce using rule 3 (class_decl -> CLASS ID { class_body_decls } .)


state 32

    (4) class_decl -> CLASS ID ( EXTENDS ID ) . { class_body_decls }

    {               shift and go to state 41


state 33

    (29) all_type -> VOID .

    )               reduce using rule 29 (all_type -> VOID .)


state 34

    (28) all_type -> type .

    )               reduce using rule 28 (all_type -> type .)


state 35

    (26) method_decl -> modifier ( all_type . ) ID ( formals ) block
    (27) method_decl -> modifier ( all_type . ) ID ( ) block

    )               shift and go to state 42


state 36

    (21) type -> ID .

    )               reduce using rule 21 (type -> ID .)
    ID              reduce using rule 21 (type -> ID .)


state 37

    (17) var_decl -> type variables .
    (22) variables -> variables . , variable

    }               reduce using rule 17 (var_decl -> type variables .)
    PUBLIC          reduce using rule 17 (var_decl -> type variables .)
    PRIVATE         reduce using rule 17 (var_decl -> type variables .)
    (               reduce using rule 17 (var_decl -> type variables .)
    ID              reduce using rule 17 (var_decl -> type variables .)
    INT             reduce using rule 17 (var_decl -> type variables .)
    FLOAT           reduce using rule 17 (var_decl -> type variables .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variables .)
    STATIC          reduce using rule 17 (var_decl -> type variables .)
    IF              reduce using rule 17 (var_decl -> type variables .)
    WHILE           reduce using rule 17 (var_decl -> type variables .)
    FOR             reduce using rule 17 (var_decl -> type variables .)
    RETURN          reduce using rule 17 (var_decl -> type variables .)
    BREAK           reduce using rule 17 (var_decl -> type variables .)
    CONTINUE        reduce using rule 17 (var_decl -> type variables .)
    {               reduce using rule 17 (var_decl -> type variables .)
    INC             reduce using rule 17 (var_decl -> type variables .)
    DEC             reduce using rule 17 (var_decl -> type variables .)
    THIS            reduce using rule 17 (var_decl -> type variables .)
    SUPER           reduce using rule 17 (var_decl -> type variables .)
    NEW             reduce using rule 17 (var_decl -> type variables .)
    INT_CONST       reduce using rule 17 (var_decl -> type variables .)
    FLOAT_CONST     reduce using rule 17 (var_decl -> type variables .)
    STRING_CONST    reduce using rule 17 (var_decl -> type variables .)
    NULL            reduce using rule 17 (var_decl -> type variables .)
    TRUE            reduce using rule 17 (var_decl -> type variables .)
    FALSE           reduce using rule 17 (var_decl -> type variables .)
    ELSE            reduce using rule 17 (var_decl -> type variables .)
    ,               shift and go to state 43


state 38

    (23) variables -> variable .
    (24) variable -> variable . [ ]

    ,               reduce using rule 23 (variables -> variable .)
    }               reduce using rule 23 (variables -> variable .)
    PUBLIC          reduce using rule 23 (variables -> variable .)
    PRIVATE         reduce using rule 23 (variables -> variable .)
    (               reduce using rule 23 (variables -> variable .)
    ID              reduce using rule 23 (variables -> variable .)
    INT             reduce using rule 23 (variables -> variable .)
    FLOAT           reduce using rule 23 (variables -> variable .)
    BOOLEAN         reduce using rule 23 (variables -> variable .)
    STATIC          reduce using rule 23 (variables -> variable .)
    IF              reduce using rule 23 (variables -> variable .)
    WHILE           reduce using rule 23 (variables -> variable .)
    FOR             reduce using rule 23 (variables -> variable .)
    RETURN          reduce using rule 23 (variables -> variable .)
    BREAK           reduce using rule 23 (variables -> variable .)
    CONTINUE        reduce using rule 23 (variables -> variable .)
    {               reduce using rule 23 (variables -> variable .)
    INC             reduce using rule 23 (variables -> variable .)
    DEC             reduce using rule 23 (variables -> variable .)
    THIS            reduce using rule 23 (variables -> variable .)
    SUPER           reduce using rule 23 (variables -> variable .)
    NEW             reduce using rule 23 (variables -> variable .)
    INT_CONST       reduce using rule 23 (variables -> variable .)
    FLOAT_CONST     reduce using rule 23 (variables -> variable .)
    STRING_CONST    reduce using rule 23 (variables -> variable .)
    NULL            reduce using rule 23 (variables -> variable .)
    TRUE            reduce using rule 23 (variables -> variable .)
    FALSE           reduce using rule 23 (variables -> variable .)
    ELSE            reduce using rule 23 (variables -> variable .)
    [               shift and go to state 44


state 39

    (25) variable -> ID .

    [               reduce using rule 25 (variable -> ID .)
    ,               reduce using rule 25 (variable -> ID .)
    }               reduce using rule 25 (variable -> ID .)
    PUBLIC          reduce using rule 25 (variable -> ID .)
    PRIVATE         reduce using rule 25 (variable -> ID .)
    (               reduce using rule 25 (variable -> ID .)
    ID              reduce using rule 25 (variable -> ID .)
    INT             reduce using rule 25 (variable -> ID .)
    FLOAT           reduce using rule 25 (variable -> ID .)
    BOOLEAN         reduce using rule 25 (variable -> ID .)
    STATIC          reduce using rule 25 (variable -> ID .)
    IF              reduce using rule 25 (variable -> ID .)
    WHILE           reduce using rule 25 (variable -> ID .)
    FOR             reduce using rule 25 (variable -> ID .)
    RETURN          reduce using rule 25 (variable -> ID .)
    BREAK           reduce using rule 25 (variable -> ID .)
    CONTINUE        reduce using rule 25 (variable -> ID .)
    {               reduce using rule 25 (variable -> ID .)
    INC             reduce using rule 25 (variable -> ID .)
    DEC             reduce using rule 25 (variable -> ID .)
    THIS            reduce using rule 25 (variable -> ID .)
    SUPER           reduce using rule 25 (variable -> ID .)
    NEW             reduce using rule 25 (variable -> ID .)
    INT_CONST       reduce using rule 25 (variable -> ID .)
    FLOAT_CONST     reduce using rule 25 (variable -> ID .)
    STRING_CONST    reduce using rule 25 (variable -> ID .)
    NULL            reduce using rule 25 (variable -> ID .)
    TRUE            reduce using rule 25 (variable -> ID .)
    FALSE           reduce using rule 25 (variable -> ID .)
    ELSE            reduce using rule 25 (variable -> ID .)
    )               reduce using rule 25 (variable -> ID .)


state 40

    (30) constructor_decl -> modifier ID ( . formals ) block
    (31) constructor_decl -> modifier ID ( . ) block
    (32) formals -> . formals , formal_param
    (33) formals -> . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               shift and go to state 46
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 45
    type                           shift and go to state 47
    formals                        shift and go to state 48

state 41

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { . class_body_decls }
    (5) class_body_decls -> . class_body_decls class_body_decl
    (6) class_body_decls -> . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (105) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)

    class_body_decl                shift and go to state 9
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17
    class_body_decls               shift and go to state 49

state 42

    (26) method_decl -> modifier ( all_type ) . ID ( formals ) block
    (27) method_decl -> modifier ( all_type ) . ID ( ) block

    ID              shift and go to state 50


state 43

    (22) variables -> variables , . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 51

state 44

    (24) variable -> variable [ . ]

    ]               shift and go to state 52


state 45

    (33) formals -> formal_param .

    )               reduce using rule 33 (formals -> formal_param .)
    ,               reduce using rule 33 (formals -> formal_param .)


state 46

    (31) constructor_decl -> modifier ID ( ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 54

state 47

    (34) formal_param -> type . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 55

state 48

    (30) constructor_decl -> modifier ID ( formals . ) block
    (32) formals -> formals . , formal_param

    )               shift and go to state 56
    ,               shift and go to state 57


state 49

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls . }
    (5) class_body_decls -> class_body_decls . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (105) empty -> .

    }               shift and go to state 58
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)

    class_body_decl                shift and go to state 30
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17

state 50

    (26) method_decl -> modifier ( all_type ) ID . ( formals ) block
    (27) method_decl -> modifier ( all_type ) ID . ( ) block

    (               shift and go to state 59


state 51

    (22) variables -> variables , variable .
    (24) variable -> variable . [ ]

    ,               reduce using rule 22 (variables -> variables , variable .)
    }               reduce using rule 22 (variables -> variables , variable .)
    PUBLIC          reduce using rule 22 (variables -> variables , variable .)
    PRIVATE         reduce using rule 22 (variables -> variables , variable .)
    (               reduce using rule 22 (variables -> variables , variable .)
    ID              reduce using rule 22 (variables -> variables , variable .)
    INT             reduce using rule 22 (variables -> variables , variable .)
    FLOAT           reduce using rule 22 (variables -> variables , variable .)
    BOOLEAN         reduce using rule 22 (variables -> variables , variable .)
    STATIC          reduce using rule 22 (variables -> variables , variable .)
    IF              reduce using rule 22 (variables -> variables , variable .)
    WHILE           reduce using rule 22 (variables -> variables , variable .)
    FOR             reduce using rule 22 (variables -> variables , variable .)
    RETURN          reduce using rule 22 (variables -> variables , variable .)
    BREAK           reduce using rule 22 (variables -> variables , variable .)
    CONTINUE        reduce using rule 22 (variables -> variables , variable .)
    {               reduce using rule 22 (variables -> variables , variable .)
    INC             reduce using rule 22 (variables -> variables , variable .)
    DEC             reduce using rule 22 (variables -> variables , variable .)
    THIS            reduce using rule 22 (variables -> variables , variable .)
    SUPER           reduce using rule 22 (variables -> variables , variable .)
    NEW             reduce using rule 22 (variables -> variables , variable .)
    INT_CONST       reduce using rule 22 (variables -> variables , variable .)
    FLOAT_CONST     reduce using rule 22 (variables -> variables , variable .)
    STRING_CONST    reduce using rule 22 (variables -> variables , variable .)
    NULL            reduce using rule 22 (variables -> variables , variable .)
    TRUE            reduce using rule 22 (variables -> variables , variable .)
    FALSE           reduce using rule 22 (variables -> variables , variable .)
    ELSE            reduce using rule 22 (variables -> variables , variable .)
    [               shift and go to state 44


state 52

    (24) variable -> variable [ ] .

    [               reduce using rule 24 (variable -> variable [ ] .)
    ,               reduce using rule 24 (variable -> variable [ ] .)
    }               reduce using rule 24 (variable -> variable [ ] .)
    PUBLIC          reduce using rule 24 (variable -> variable [ ] .)
    PRIVATE         reduce using rule 24 (variable -> variable [ ] .)
    (               reduce using rule 24 (variable -> variable [ ] .)
    ID              reduce using rule 24 (variable -> variable [ ] .)
    INT             reduce using rule 24 (variable -> variable [ ] .)
    FLOAT           reduce using rule 24 (variable -> variable [ ] .)
    BOOLEAN         reduce using rule 24 (variable -> variable [ ] .)
    STATIC          reduce using rule 24 (variable -> variable [ ] .)
    IF              reduce using rule 24 (variable -> variable [ ] .)
    WHILE           reduce using rule 24 (variable -> variable [ ] .)
    FOR             reduce using rule 24 (variable -> variable [ ] .)
    RETURN          reduce using rule 24 (variable -> variable [ ] .)
    BREAK           reduce using rule 24 (variable -> variable [ ] .)
    CONTINUE        reduce using rule 24 (variable -> variable [ ] .)
    {               reduce using rule 24 (variable -> variable [ ] .)
    INC             reduce using rule 24 (variable -> variable [ ] .)
    DEC             reduce using rule 24 (variable -> variable [ ] .)
    THIS            reduce using rule 24 (variable -> variable [ ] .)
    SUPER           reduce using rule 24 (variable -> variable [ ] .)
    NEW             reduce using rule 24 (variable -> variable [ ] .)
    INT_CONST       reduce using rule 24 (variable -> variable [ ] .)
    FLOAT_CONST     reduce using rule 24 (variable -> variable [ ] .)
    STRING_CONST    reduce using rule 24 (variable -> variable [ ] .)
    NULL            reduce using rule 24 (variable -> variable [ ] .)
    TRUE            reduce using rule 24 (variable -> variable [ ] .)
    FALSE           reduce using rule 24 (variable -> variable [ ] .)
    ELSE            reduce using rule 24 (variable -> variable [ ] .)
    )               reduce using rule 24 (variable -> variable [ ] .)


state 53

    (35) block -> { . stmts }
    (36) stmts -> . stmts stmt
    (37) stmts -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    BREAK           reduce using rule 105 (empty -> .)
    CONTINUE        reduce using rule 105 (empty -> .)
    {               reduce using rule 105 (empty -> .)
    INC             reduce using rule 105 (empty -> .)
    DEC             reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    BOOLEAN         reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    THIS            reduce using rule 105 (empty -> .)
    SUPER           reduce using rule 105 (empty -> .)
    (               reduce using rule 105 (empty -> .)
    NEW             reduce using rule 105 (empty -> .)
    INT_CONST       reduce using rule 105 (empty -> .)
    FLOAT_CONST     reduce using rule 105 (empty -> .)
    STRING_CONST    reduce using rule 105 (empty -> .)
    NULL            reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)

    stmts                          shift and go to state 60
    empty                          shift and go to state 61

state 54

    (31) constructor_decl -> modifier ID ( ) block .

    }               reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    PUBLIC          reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    PRIVATE         reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    (               reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    ID              reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    INT             reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    FLOAT           reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    BOOLEAN         reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    STATIC          reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)


state 55

    (34) formal_param -> type variable .
    (24) variable -> variable . [ ]

    )               reduce using rule 34 (formal_param -> type variable .)
    ,               reduce using rule 34 (formal_param -> type variable .)
    [               shift and go to state 44


state 56

    (30) constructor_decl -> modifier ID ( formals ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 62

state 57

    (32) formals -> formals , . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 63
    type                           shift and go to state 47

state 58

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .)
    $end            reduce using rule 4 (class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .)


state 59

    (26) method_decl -> modifier ( all_type ) ID ( . formals ) block
    (27) method_decl -> modifier ( all_type ) ID ( . ) block
    (32) formals -> . formals , formal_param
    (33) formals -> . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               shift and go to state 64
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 45
    type                           shift and go to state 47
    formals                        shift and go to state 65

state 60

    (35) block -> { stmts . }
    (36) stmts -> stmts . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( stmt_expr ; expr ; stmt_expr ) stmt
    (42) stmt -> . RETURN exprs
    (43) stmt -> . stmt_expr
    (44) stmt -> . BREAK
    (45) stmt -> . CONTINUE
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    }               shift and go to state 93
    IF              shift and go to state 87
    WHILE           shift and go to state 68
    FOR             shift and go to state 81
    RETURN          shift and go to state 66
    BREAK           shift and go to state 90
    CONTINUE        shift and go to state 91
    {               shift and go to state 53
    INC             shift and go to state 96
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 85
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    stmt_expr                      shift and go to state 77
    primary                        shift and go to state 67
    stmt                           shift and go to state 83
    literal                        shift and go to state 78
    array_access                   shift and go to state 72
    lhs                            shift and go to state 92
    var_decl                       shift and go to state 89
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 61

    (37) stmts -> empty .

    }               reduce using rule 37 (stmts -> empty .)
    IF              reduce using rule 37 (stmts -> empty .)
    WHILE           reduce using rule 37 (stmts -> empty .)
    FOR             reduce using rule 37 (stmts -> empty .)
    RETURN          reduce using rule 37 (stmts -> empty .)
    BREAK           reduce using rule 37 (stmts -> empty .)
    CONTINUE        reduce using rule 37 (stmts -> empty .)
    {               reduce using rule 37 (stmts -> empty .)
    INC             reduce using rule 37 (stmts -> empty .)
    DEC             reduce using rule 37 (stmts -> empty .)
    INT             reduce using rule 37 (stmts -> empty .)
    FLOAT           reduce using rule 37 (stmts -> empty .)
    BOOLEAN         reduce using rule 37 (stmts -> empty .)
    ID              reduce using rule 37 (stmts -> empty .)
    THIS            reduce using rule 37 (stmts -> empty .)
    SUPER           reduce using rule 37 (stmts -> empty .)
    (               reduce using rule 37 (stmts -> empty .)
    NEW             reduce using rule 37 (stmts -> empty .)
    INT_CONST       reduce using rule 37 (stmts -> empty .)
    FLOAT_CONST     reduce using rule 37 (stmts -> empty .)
    STRING_CONST    reduce using rule 37 (stmts -> empty .)
    NULL            reduce using rule 37 (stmts -> empty .)
    TRUE            reduce using rule 37 (stmts -> empty .)
    FALSE           reduce using rule 37 (stmts -> empty .)


state 62

    (30) constructor_decl -> modifier ID ( formals ) block .

    }               reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    (               reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    STATIC          reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)


state 63

    (32) formals -> formals , formal_param .

    )               reduce using rule 32 (formals -> formals , formal_param .)
    ,               reduce using rule 32 (formals -> formals , formal_param .)


state 64

    (27) method_decl -> modifier ( all_type ) ID ( ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 97

state 65

    (26) method_decl -> modifier ( all_type ) ID ( formals . ) block
    (32) formals -> formals . , formal_param

    )               shift and go to state 98
    ,               shift and go to state 57


state 66

    (42) stmt -> RETURN . exprs
    (48) exprs -> . exprs expr
    (49) exprs -> . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    expr                           shift and go to state 110
    primary                        shift and go to state 100
    exprs                          shift and go to state 111
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 107
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 67

    (69) field_access -> primary . . ID
    (71) array_access -> primary . [ expr ]

    .               shift and go to state 114
    [               shift and go to state 115


state 68

    (40) stmt -> WHILE . ( expr ) stmt

    (               shift and go to state 116


state 69

    (51) literal -> FLOAT_CONST .

    .               reduce using rule 51 (literal -> FLOAT_CONST .)
    [               reduce using rule 51 (literal -> FLOAT_CONST .)
    +               reduce using rule 51 (literal -> FLOAT_CONST .)
    -               reduce using rule 51 (literal -> FLOAT_CONST .)
    *               reduce using rule 51 (literal -> FLOAT_CONST .)
    /               reduce using rule 51 (literal -> FLOAT_CONST .)
    AND             reduce using rule 51 (literal -> FLOAT_CONST .)
    OR              reduce using rule 51 (literal -> FLOAT_CONST .)
    EQL             reduce using rule 51 (literal -> FLOAT_CONST .)
    UNEQL           reduce using rule 51 (literal -> FLOAT_CONST .)
    <               reduce using rule 51 (literal -> FLOAT_CONST .)
    >               reduce using rule 51 (literal -> FLOAT_CONST .)
    LE              reduce using rule 51 (literal -> FLOAT_CONST .)
    GE              reduce using rule 51 (literal -> FLOAT_CONST .)
    THIS            reduce using rule 51 (literal -> FLOAT_CONST .)
    SUPER           reduce using rule 51 (literal -> FLOAT_CONST .)
    (               reduce using rule 51 (literal -> FLOAT_CONST .)
    NEW             reduce using rule 51 (literal -> FLOAT_CONST .)
    INC             reduce using rule 51 (literal -> FLOAT_CONST .)
    DEC             reduce using rule 51 (literal -> FLOAT_CONST .)
    !               reduce using rule 51 (literal -> FLOAT_CONST .)
    INT_CONST       reduce using rule 51 (literal -> FLOAT_CONST .)
    FLOAT_CONST     reduce using rule 51 (literal -> FLOAT_CONST .)
    STRING_CONST    reduce using rule 51 (literal -> FLOAT_CONST .)
    NULL            reduce using rule 51 (literal -> FLOAT_CONST .)
    TRUE            reduce using rule 51 (literal -> FLOAT_CONST .)
    FALSE           reduce using rule 51 (literal -> FLOAT_CONST .)
    ID              reduce using rule 51 (literal -> FLOAT_CONST .)
    }               reduce using rule 51 (literal -> FLOAT_CONST .)
    IF              reduce using rule 51 (literal -> FLOAT_CONST .)
    WHILE           reduce using rule 51 (literal -> FLOAT_CONST .)
    FOR             reduce using rule 51 (literal -> FLOAT_CONST .)
    RETURN          reduce using rule 51 (literal -> FLOAT_CONST .)
    BREAK           reduce using rule 51 (literal -> FLOAT_CONST .)
    CONTINUE        reduce using rule 51 (literal -> FLOAT_CONST .)
    {               reduce using rule 51 (literal -> FLOAT_CONST .)
    INT             reduce using rule 51 (literal -> FLOAT_CONST .)
    FLOAT           reduce using rule 51 (literal -> FLOAT_CONST .)
    BOOLEAN         reduce using rule 51 (literal -> FLOAT_CONST .)
    ELSE            reduce using rule 51 (literal -> FLOAT_CONST .)
    ;               reduce using rule 51 (literal -> FLOAT_CONST .)
    )               reduce using rule 51 (literal -> FLOAT_CONST .)
    ]               reduce using rule 51 (literal -> FLOAT_CONST .)
    ,               reduce using rule 51 (literal -> FLOAT_CONST .)


state 70

    (60) primary -> NEW . ID ( have_arguments )

    ID              shift and go to state 117


state 71

    (83) assign -> DEC . lhs
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (72) method_invocation -> . field_access ( have_arguments )

    ID              shift and go to state 109
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 107
    primary                        shift and go to state 67
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72

state 72

    (68) lhs -> array_access .

    =               reduce using rule 68 (lhs -> array_access .)
    INC             reduce using rule 68 (lhs -> array_access .)
    DEC             reduce using rule 68 (lhs -> array_access .)
    .               reduce using rule 68 (lhs -> array_access .)
    [               reduce using rule 68 (lhs -> array_access .)
    +               reduce using rule 68 (lhs -> array_access .)
    -               reduce using rule 68 (lhs -> array_access .)
    *               reduce using rule 68 (lhs -> array_access .)
    /               reduce using rule 68 (lhs -> array_access .)
    AND             reduce using rule 68 (lhs -> array_access .)
    OR              reduce using rule 68 (lhs -> array_access .)
    EQL             reduce using rule 68 (lhs -> array_access .)
    UNEQL           reduce using rule 68 (lhs -> array_access .)
    <               reduce using rule 68 (lhs -> array_access .)
    >               reduce using rule 68 (lhs -> array_access .)
    LE              reduce using rule 68 (lhs -> array_access .)
    GE              reduce using rule 68 (lhs -> array_access .)
    THIS            reduce using rule 68 (lhs -> array_access .)
    SUPER           reduce using rule 68 (lhs -> array_access .)
    (               reduce using rule 68 (lhs -> array_access .)
    NEW             reduce using rule 68 (lhs -> array_access .)
    !               reduce using rule 68 (lhs -> array_access .)
    INT_CONST       reduce using rule 68 (lhs -> array_access .)
    FLOAT_CONST     reduce using rule 68 (lhs -> array_access .)
    STRING_CONST    reduce using rule 68 (lhs -> array_access .)
    NULL            reduce using rule 68 (lhs -> array_access .)
    TRUE            reduce using rule 68 (lhs -> array_access .)
    FALSE           reduce using rule 68 (lhs -> array_access .)
    ID              reduce using rule 68 (lhs -> array_access .)
    }               reduce using rule 68 (lhs -> array_access .)
    IF              reduce using rule 68 (lhs -> array_access .)
    WHILE           reduce using rule 68 (lhs -> array_access .)
    FOR             reduce using rule 68 (lhs -> array_access .)
    RETURN          reduce using rule 68 (lhs -> array_access .)
    BREAK           reduce using rule 68 (lhs -> array_access .)
    CONTINUE        reduce using rule 68 (lhs -> array_access .)
    {               reduce using rule 68 (lhs -> array_access .)
    INT             reduce using rule 68 (lhs -> array_access .)
    FLOAT           reduce using rule 68 (lhs -> array_access .)
    BOOLEAN         reduce using rule 68 (lhs -> array_access .)
    ELSE            reduce using rule 68 (lhs -> array_access .)
    )               reduce using rule 68 (lhs -> array_access .)
    ]               reduce using rule 68 (lhs -> array_access .)
    ,               reduce using rule 68 (lhs -> array_access .)
    ;               reduce using rule 68 (lhs -> array_access .)


state 73

    (52) literal -> STRING_CONST .

    .               reduce using rule 52 (literal -> STRING_CONST .)
    [               reduce using rule 52 (literal -> STRING_CONST .)
    +               reduce using rule 52 (literal -> STRING_CONST .)
    -               reduce using rule 52 (literal -> STRING_CONST .)
    *               reduce using rule 52 (literal -> STRING_CONST .)
    /               reduce using rule 52 (literal -> STRING_CONST .)
    AND             reduce using rule 52 (literal -> STRING_CONST .)
    OR              reduce using rule 52 (literal -> STRING_CONST .)
    EQL             reduce using rule 52 (literal -> STRING_CONST .)
    UNEQL           reduce using rule 52 (literal -> STRING_CONST .)
    <               reduce using rule 52 (literal -> STRING_CONST .)
    >               reduce using rule 52 (literal -> STRING_CONST .)
    LE              reduce using rule 52 (literal -> STRING_CONST .)
    GE              reduce using rule 52 (literal -> STRING_CONST .)
    THIS            reduce using rule 52 (literal -> STRING_CONST .)
    SUPER           reduce using rule 52 (literal -> STRING_CONST .)
    (               reduce using rule 52 (literal -> STRING_CONST .)
    NEW             reduce using rule 52 (literal -> STRING_CONST .)
    INC             reduce using rule 52 (literal -> STRING_CONST .)
    DEC             reduce using rule 52 (literal -> STRING_CONST .)
    !               reduce using rule 52 (literal -> STRING_CONST .)
    INT_CONST       reduce using rule 52 (literal -> STRING_CONST .)
    FLOAT_CONST     reduce using rule 52 (literal -> STRING_CONST .)
    STRING_CONST    reduce using rule 52 (literal -> STRING_CONST .)
    NULL            reduce using rule 52 (literal -> STRING_CONST .)
    TRUE            reduce using rule 52 (literal -> STRING_CONST .)
    FALSE           reduce using rule 52 (literal -> STRING_CONST .)
    ID              reduce using rule 52 (literal -> STRING_CONST .)
    }               reduce using rule 52 (literal -> STRING_CONST .)
    IF              reduce using rule 52 (literal -> STRING_CONST .)
    WHILE           reduce using rule 52 (literal -> STRING_CONST .)
    FOR             reduce using rule 52 (literal -> STRING_CONST .)
    RETURN          reduce using rule 52 (literal -> STRING_CONST .)
    BREAK           reduce using rule 52 (literal -> STRING_CONST .)
    CONTINUE        reduce using rule 52 (literal -> STRING_CONST .)
    {               reduce using rule 52 (literal -> STRING_CONST .)
    INT             reduce using rule 52 (literal -> STRING_CONST .)
    FLOAT           reduce using rule 52 (literal -> STRING_CONST .)
    BOOLEAN         reduce using rule 52 (literal -> STRING_CONST .)
    ELSE            reduce using rule 52 (literal -> STRING_CONST .)
    ;               reduce using rule 52 (literal -> STRING_CONST .)
    )               reduce using rule 52 (literal -> STRING_CONST .)
    ]               reduce using rule 52 (literal -> STRING_CONST .)
    ,               reduce using rule 52 (literal -> STRING_CONST .)


state 74

    (50) literal -> INT_CONST .

    .               reduce using rule 50 (literal -> INT_CONST .)
    [               reduce using rule 50 (literal -> INT_CONST .)
    +               reduce using rule 50 (literal -> INT_CONST .)
    -               reduce using rule 50 (literal -> INT_CONST .)
    *               reduce using rule 50 (literal -> INT_CONST .)
    /               reduce using rule 50 (literal -> INT_CONST .)
    AND             reduce using rule 50 (literal -> INT_CONST .)
    OR              reduce using rule 50 (literal -> INT_CONST .)
    EQL             reduce using rule 50 (literal -> INT_CONST .)
    UNEQL           reduce using rule 50 (literal -> INT_CONST .)
    <               reduce using rule 50 (literal -> INT_CONST .)
    >               reduce using rule 50 (literal -> INT_CONST .)
    LE              reduce using rule 50 (literal -> INT_CONST .)
    GE              reduce using rule 50 (literal -> INT_CONST .)
    THIS            reduce using rule 50 (literal -> INT_CONST .)
    SUPER           reduce using rule 50 (literal -> INT_CONST .)
    (               reduce using rule 50 (literal -> INT_CONST .)
    NEW             reduce using rule 50 (literal -> INT_CONST .)
    INC             reduce using rule 50 (literal -> INT_CONST .)
    DEC             reduce using rule 50 (literal -> INT_CONST .)
    !               reduce using rule 50 (literal -> INT_CONST .)
    INT_CONST       reduce using rule 50 (literal -> INT_CONST .)
    FLOAT_CONST     reduce using rule 50 (literal -> INT_CONST .)
    STRING_CONST    reduce using rule 50 (literal -> INT_CONST .)
    NULL            reduce using rule 50 (literal -> INT_CONST .)
    TRUE            reduce using rule 50 (literal -> INT_CONST .)
    FALSE           reduce using rule 50 (literal -> INT_CONST .)
    ID              reduce using rule 50 (literal -> INT_CONST .)
    }               reduce using rule 50 (literal -> INT_CONST .)
    IF              reduce using rule 50 (literal -> INT_CONST .)
    WHILE           reduce using rule 50 (literal -> INT_CONST .)
    FOR             reduce using rule 50 (literal -> INT_CONST .)
    RETURN          reduce using rule 50 (literal -> INT_CONST .)
    BREAK           reduce using rule 50 (literal -> INT_CONST .)
    CONTINUE        reduce using rule 50 (literal -> INT_CONST .)
    {               reduce using rule 50 (literal -> INT_CONST .)
    INT             reduce using rule 50 (literal -> INT_CONST .)
    FLOAT           reduce using rule 50 (literal -> INT_CONST .)
    BOOLEAN         reduce using rule 50 (literal -> INT_CONST .)
    ELSE            reduce using rule 50 (literal -> INT_CONST .)
    ;               reduce using rule 50 (literal -> INT_CONST .)
    )               reduce using rule 50 (literal -> INT_CONST .)
    ]               reduce using rule 50 (literal -> INT_CONST .)
    ,               reduce using rule 50 (literal -> INT_CONST .)


state 75

    (59) primary -> ( . expr )
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 119
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 76

    (53) literal -> NULL .

    .               reduce using rule 53 (literal -> NULL .)
    [               reduce using rule 53 (literal -> NULL .)
    +               reduce using rule 53 (literal -> NULL .)
    -               reduce using rule 53 (literal -> NULL .)
    *               reduce using rule 53 (literal -> NULL .)
    /               reduce using rule 53 (literal -> NULL .)
    AND             reduce using rule 53 (literal -> NULL .)
    OR              reduce using rule 53 (literal -> NULL .)
    EQL             reduce using rule 53 (literal -> NULL .)
    UNEQL           reduce using rule 53 (literal -> NULL .)
    <               reduce using rule 53 (literal -> NULL .)
    >               reduce using rule 53 (literal -> NULL .)
    LE              reduce using rule 53 (literal -> NULL .)
    GE              reduce using rule 53 (literal -> NULL .)
    THIS            reduce using rule 53 (literal -> NULL .)
    SUPER           reduce using rule 53 (literal -> NULL .)
    (               reduce using rule 53 (literal -> NULL .)
    NEW             reduce using rule 53 (literal -> NULL .)
    INC             reduce using rule 53 (literal -> NULL .)
    DEC             reduce using rule 53 (literal -> NULL .)
    !               reduce using rule 53 (literal -> NULL .)
    INT_CONST       reduce using rule 53 (literal -> NULL .)
    FLOAT_CONST     reduce using rule 53 (literal -> NULL .)
    STRING_CONST    reduce using rule 53 (literal -> NULL .)
    NULL            reduce using rule 53 (literal -> NULL .)
    TRUE            reduce using rule 53 (literal -> NULL .)
    FALSE           reduce using rule 53 (literal -> NULL .)
    ID              reduce using rule 53 (literal -> NULL .)
    }               reduce using rule 53 (literal -> NULL .)
    IF              reduce using rule 53 (literal -> NULL .)
    WHILE           reduce using rule 53 (literal -> NULL .)
    FOR             reduce using rule 53 (literal -> NULL .)
    RETURN          reduce using rule 53 (literal -> NULL .)
    BREAK           reduce using rule 53 (literal -> NULL .)
    CONTINUE        reduce using rule 53 (literal -> NULL .)
    {               reduce using rule 53 (literal -> NULL .)
    INT             reduce using rule 53 (literal -> NULL .)
    FLOAT           reduce using rule 53 (literal -> NULL .)
    BOOLEAN         reduce using rule 53 (literal -> NULL .)
    ELSE            reduce using rule 53 (literal -> NULL .)
    ;               reduce using rule 53 (literal -> NULL .)
    )               reduce using rule 53 (literal -> NULL .)
    ]               reduce using rule 53 (literal -> NULL .)
    ,               reduce using rule 53 (literal -> NULL .)


state 77

    (43) stmt -> stmt_expr .

    }               reduce using rule 43 (stmt -> stmt_expr .)
    IF              reduce using rule 43 (stmt -> stmt_expr .)
    WHILE           reduce using rule 43 (stmt -> stmt_expr .)
    FOR             reduce using rule 43 (stmt -> stmt_expr .)
    RETURN          reduce using rule 43 (stmt -> stmt_expr .)
    BREAK           reduce using rule 43 (stmt -> stmt_expr .)
    CONTINUE        reduce using rule 43 (stmt -> stmt_expr .)
    {               reduce using rule 43 (stmt -> stmt_expr .)
    INC             reduce using rule 43 (stmt -> stmt_expr .)
    DEC             reduce using rule 43 (stmt -> stmt_expr .)
    INT             reduce using rule 43 (stmt -> stmt_expr .)
    FLOAT           reduce using rule 43 (stmt -> stmt_expr .)
    BOOLEAN         reduce using rule 43 (stmt -> stmt_expr .)
    ID              reduce using rule 43 (stmt -> stmt_expr .)
    THIS            reduce using rule 43 (stmt -> stmt_expr .)
    SUPER           reduce using rule 43 (stmt -> stmt_expr .)
    (               reduce using rule 43 (stmt -> stmt_expr .)
    NEW             reduce using rule 43 (stmt -> stmt_expr .)
    INT_CONST       reduce using rule 43 (stmt -> stmt_expr .)
    FLOAT_CONST     reduce using rule 43 (stmt -> stmt_expr .)
    STRING_CONST    reduce using rule 43 (stmt -> stmt_expr .)
    NULL            reduce using rule 43 (stmt -> stmt_expr .)
    TRUE            reduce using rule 43 (stmt -> stmt_expr .)
    FALSE           reduce using rule 43 (stmt -> stmt_expr .)
    ELSE            reduce using rule 43 (stmt -> stmt_expr .)


state 78

    (56) primary -> literal .

    .               reduce using rule 56 (primary -> literal .)
    [               reduce using rule 56 (primary -> literal .)
    )               reduce using rule 56 (primary -> literal .)
    +               reduce using rule 56 (primary -> literal .)
    -               reduce using rule 56 (primary -> literal .)
    *               reduce using rule 56 (primary -> literal .)
    /               reduce using rule 56 (primary -> literal .)
    AND             reduce using rule 56 (primary -> literal .)
    OR              reduce using rule 56 (primary -> literal .)
    EQL             reduce using rule 56 (primary -> literal .)
    UNEQL           reduce using rule 56 (primary -> literal .)
    <               reduce using rule 56 (primary -> literal .)
    >               reduce using rule 56 (primary -> literal .)
    LE              reduce using rule 56 (primary -> literal .)
    GE              reduce using rule 56 (primary -> literal .)
    ]               reduce using rule 56 (primary -> literal .)
    THIS            reduce using rule 56 (primary -> literal .)
    SUPER           reduce using rule 56 (primary -> literal .)
    (               reduce using rule 56 (primary -> literal .)
    NEW             reduce using rule 56 (primary -> literal .)
    INC             reduce using rule 56 (primary -> literal .)
    DEC             reduce using rule 56 (primary -> literal .)
    !               reduce using rule 56 (primary -> literal .)
    INT_CONST       reduce using rule 56 (primary -> literal .)
    FLOAT_CONST     reduce using rule 56 (primary -> literal .)
    STRING_CONST    reduce using rule 56 (primary -> literal .)
    NULL            reduce using rule 56 (primary -> literal .)
    TRUE            reduce using rule 56 (primary -> literal .)
    FALSE           reduce using rule 56 (primary -> literal .)
    ID              reduce using rule 56 (primary -> literal .)
    }               reduce using rule 56 (primary -> literal .)
    IF              reduce using rule 56 (primary -> literal .)
    WHILE           reduce using rule 56 (primary -> literal .)
    FOR             reduce using rule 56 (primary -> literal .)
    RETURN          reduce using rule 56 (primary -> literal .)
    BREAK           reduce using rule 56 (primary -> literal .)
    CONTINUE        reduce using rule 56 (primary -> literal .)
    {               reduce using rule 56 (primary -> literal .)
    INT             reduce using rule 56 (primary -> literal .)
    FLOAT           reduce using rule 56 (primary -> literal .)
    BOOLEAN         reduce using rule 56 (primary -> literal .)
    ELSE            reduce using rule 56 (primary -> literal .)
    ,               reduce using rule 56 (primary -> literal .)
    ;               reduce using rule 56 (primary -> literal .)


state 79

    (104) stmt_expr -> method_invocation .
    (62) primary -> method_invocation .

    }               reduce using rule 104 (stmt_expr -> method_invocation .)
    IF              reduce using rule 104 (stmt_expr -> method_invocation .)
    WHILE           reduce using rule 104 (stmt_expr -> method_invocation .)
    FOR             reduce using rule 104 (stmt_expr -> method_invocation .)
    RETURN          reduce using rule 104 (stmt_expr -> method_invocation .)
    BREAK           reduce using rule 104 (stmt_expr -> method_invocation .)
    CONTINUE        reduce using rule 104 (stmt_expr -> method_invocation .)
    {               reduce using rule 104 (stmt_expr -> method_invocation .)
    INC             reduce using rule 104 (stmt_expr -> method_invocation .)
    DEC             reduce using rule 104 (stmt_expr -> method_invocation .)
    INT             reduce using rule 104 (stmt_expr -> method_invocation .)
    FLOAT           reduce using rule 104 (stmt_expr -> method_invocation .)
    BOOLEAN         reduce using rule 104 (stmt_expr -> method_invocation .)
    ID              reduce using rule 104 (stmt_expr -> method_invocation .)
    THIS            reduce using rule 104 (stmt_expr -> method_invocation .)
    SUPER           reduce using rule 104 (stmt_expr -> method_invocation .)
    (               reduce using rule 104 (stmt_expr -> method_invocation .)
    NEW             reduce using rule 104 (stmt_expr -> method_invocation .)
    INT_CONST       reduce using rule 104 (stmt_expr -> method_invocation .)
    FLOAT_CONST     reduce using rule 104 (stmt_expr -> method_invocation .)
    STRING_CONST    reduce using rule 104 (stmt_expr -> method_invocation .)
    NULL            reduce using rule 104 (stmt_expr -> method_invocation .)
    TRUE            reduce using rule 104 (stmt_expr -> method_invocation .)
    FALSE           reduce using rule 104 (stmt_expr -> method_invocation .)
    ELSE            reduce using rule 104 (stmt_expr -> method_invocation .)
    ;               reduce using rule 104 (stmt_expr -> method_invocation .)
    )               reduce using rule 104 (stmt_expr -> method_invocation .)
    .               reduce using rule 62 (primary -> method_invocation .)
    [               reduce using rule 62 (primary -> method_invocation .)


state 80

    (72) method_invocation -> field_access . ( have_arguments )
    (67) lhs -> field_access .

    (               shift and go to state 120
    =               reduce using rule 67 (lhs -> field_access .)
    INC             reduce using rule 67 (lhs -> field_access .)
    DEC             reduce using rule 67 (lhs -> field_access .)
    .               reduce using rule 67 (lhs -> field_access .)
    [               reduce using rule 67 (lhs -> field_access .)


state 81

    (41) stmt -> FOR . ( stmt_expr ; expr ; stmt_expr ) stmt

    (               shift and go to state 121


state 82

    (58) primary -> SUPER .

    .               reduce using rule 58 (primary -> SUPER .)
    [               reduce using rule 58 (primary -> SUPER .)
    )               reduce using rule 58 (primary -> SUPER .)
    +               reduce using rule 58 (primary -> SUPER .)
    -               reduce using rule 58 (primary -> SUPER .)
    *               reduce using rule 58 (primary -> SUPER .)
    /               reduce using rule 58 (primary -> SUPER .)
    AND             reduce using rule 58 (primary -> SUPER .)
    OR              reduce using rule 58 (primary -> SUPER .)
    EQL             reduce using rule 58 (primary -> SUPER .)
    UNEQL           reduce using rule 58 (primary -> SUPER .)
    <               reduce using rule 58 (primary -> SUPER .)
    >               reduce using rule 58 (primary -> SUPER .)
    LE              reduce using rule 58 (primary -> SUPER .)
    GE              reduce using rule 58 (primary -> SUPER .)
    ]               reduce using rule 58 (primary -> SUPER .)
    THIS            reduce using rule 58 (primary -> SUPER .)
    SUPER           reduce using rule 58 (primary -> SUPER .)
    (               reduce using rule 58 (primary -> SUPER .)
    NEW             reduce using rule 58 (primary -> SUPER .)
    INC             reduce using rule 58 (primary -> SUPER .)
    DEC             reduce using rule 58 (primary -> SUPER .)
    !               reduce using rule 58 (primary -> SUPER .)
    INT_CONST       reduce using rule 58 (primary -> SUPER .)
    FLOAT_CONST     reduce using rule 58 (primary -> SUPER .)
    STRING_CONST    reduce using rule 58 (primary -> SUPER .)
    NULL            reduce using rule 58 (primary -> SUPER .)
    TRUE            reduce using rule 58 (primary -> SUPER .)
    FALSE           reduce using rule 58 (primary -> SUPER .)
    ID              reduce using rule 58 (primary -> SUPER .)
    }               reduce using rule 58 (primary -> SUPER .)
    IF              reduce using rule 58 (primary -> SUPER .)
    WHILE           reduce using rule 58 (primary -> SUPER .)
    FOR             reduce using rule 58 (primary -> SUPER .)
    RETURN          reduce using rule 58 (primary -> SUPER .)
    BREAK           reduce using rule 58 (primary -> SUPER .)
    CONTINUE        reduce using rule 58 (primary -> SUPER .)
    {               reduce using rule 58 (primary -> SUPER .)
    INT             reduce using rule 58 (primary -> SUPER .)
    FLOAT           reduce using rule 58 (primary -> SUPER .)
    BOOLEAN         reduce using rule 58 (primary -> SUPER .)
    ELSE            reduce using rule 58 (primary -> SUPER .)
    ,               reduce using rule 58 (primary -> SUPER .)
    ;               reduce using rule 58 (primary -> SUPER .)


state 83

    (36) stmts -> stmts stmt .

    }               reduce using rule 36 (stmts -> stmts stmt .)
    IF              reduce using rule 36 (stmts -> stmts stmt .)
    WHILE           reduce using rule 36 (stmts -> stmts stmt .)
    FOR             reduce using rule 36 (stmts -> stmts stmt .)
    RETURN          reduce using rule 36 (stmts -> stmts stmt .)
    BREAK           reduce using rule 36 (stmts -> stmts stmt .)
    CONTINUE        reduce using rule 36 (stmts -> stmts stmt .)
    {               reduce using rule 36 (stmts -> stmts stmt .)
    INC             reduce using rule 36 (stmts -> stmts stmt .)
    DEC             reduce using rule 36 (stmts -> stmts stmt .)
    INT             reduce using rule 36 (stmts -> stmts stmt .)
    FLOAT           reduce using rule 36 (stmts -> stmts stmt .)
    BOOLEAN         reduce using rule 36 (stmts -> stmts stmt .)
    ID              reduce using rule 36 (stmts -> stmts stmt .)
    THIS            reduce using rule 36 (stmts -> stmts stmt .)
    SUPER           reduce using rule 36 (stmts -> stmts stmt .)
    (               reduce using rule 36 (stmts -> stmts stmt .)
    NEW             reduce using rule 36 (stmts -> stmts stmt .)
    INT_CONST       reduce using rule 36 (stmts -> stmts stmt .)
    FLOAT_CONST     reduce using rule 36 (stmts -> stmts stmt .)
    STRING_CONST    reduce using rule 36 (stmts -> stmts stmt .)
    NULL            reduce using rule 36 (stmts -> stmts stmt .)
    TRUE            reduce using rule 36 (stmts -> stmts stmt .)
    FALSE           reduce using rule 36 (stmts -> stmts stmt .)


state 84

    (57) primary -> THIS .

    .               reduce using rule 57 (primary -> THIS .)
    [               reduce using rule 57 (primary -> THIS .)
    )               reduce using rule 57 (primary -> THIS .)
    +               reduce using rule 57 (primary -> THIS .)
    -               reduce using rule 57 (primary -> THIS .)
    *               reduce using rule 57 (primary -> THIS .)
    /               reduce using rule 57 (primary -> THIS .)
    AND             reduce using rule 57 (primary -> THIS .)
    OR              reduce using rule 57 (primary -> THIS .)
    EQL             reduce using rule 57 (primary -> THIS .)
    UNEQL           reduce using rule 57 (primary -> THIS .)
    <               reduce using rule 57 (primary -> THIS .)
    >               reduce using rule 57 (primary -> THIS .)
    LE              reduce using rule 57 (primary -> THIS .)
    GE              reduce using rule 57 (primary -> THIS .)
    ]               reduce using rule 57 (primary -> THIS .)
    THIS            reduce using rule 57 (primary -> THIS .)
    SUPER           reduce using rule 57 (primary -> THIS .)
    (               reduce using rule 57 (primary -> THIS .)
    NEW             reduce using rule 57 (primary -> THIS .)
    INC             reduce using rule 57 (primary -> THIS .)
    DEC             reduce using rule 57 (primary -> THIS .)
    !               reduce using rule 57 (primary -> THIS .)
    INT_CONST       reduce using rule 57 (primary -> THIS .)
    FLOAT_CONST     reduce using rule 57 (primary -> THIS .)
    STRING_CONST    reduce using rule 57 (primary -> THIS .)
    NULL            reduce using rule 57 (primary -> THIS .)
    TRUE            reduce using rule 57 (primary -> THIS .)
    FALSE           reduce using rule 57 (primary -> THIS .)
    ID              reduce using rule 57 (primary -> THIS .)
    }               reduce using rule 57 (primary -> THIS .)
    IF              reduce using rule 57 (primary -> THIS .)
    WHILE           reduce using rule 57 (primary -> THIS .)
    FOR             reduce using rule 57 (primary -> THIS .)
    RETURN          reduce using rule 57 (primary -> THIS .)
    BREAK           reduce using rule 57 (primary -> THIS .)
    CONTINUE        reduce using rule 57 (primary -> THIS .)
    {               reduce using rule 57 (primary -> THIS .)
    INT             reduce using rule 57 (primary -> THIS .)
    FLOAT           reduce using rule 57 (primary -> THIS .)
    BOOLEAN         reduce using rule 57 (primary -> THIS .)
    ELSE            reduce using rule 57 (primary -> THIS .)
    ,               reduce using rule 57 (primary -> THIS .)
    ;               reduce using rule 57 (primary -> THIS .)


state 85

    (21) type -> ID .
    (70) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    (               reduce using rule 70 (field_access -> ID .)
    =               reduce using rule 70 (field_access -> ID .)
    INC             reduce using rule 70 (field_access -> ID .)
    DEC             reduce using rule 70 (field_access -> ID .)
    .               reduce using rule 70 (field_access -> ID .)
    [               reduce using rule 70 (field_access -> ID .)


state 86

    (54) literal -> TRUE .

    .               reduce using rule 54 (literal -> TRUE .)
    [               reduce using rule 54 (literal -> TRUE .)
    +               reduce using rule 54 (literal -> TRUE .)
    -               reduce using rule 54 (literal -> TRUE .)
    *               reduce using rule 54 (literal -> TRUE .)
    /               reduce using rule 54 (literal -> TRUE .)
    AND             reduce using rule 54 (literal -> TRUE .)
    OR              reduce using rule 54 (literal -> TRUE .)
    EQL             reduce using rule 54 (literal -> TRUE .)
    UNEQL           reduce using rule 54 (literal -> TRUE .)
    <               reduce using rule 54 (literal -> TRUE .)
    >               reduce using rule 54 (literal -> TRUE .)
    LE              reduce using rule 54 (literal -> TRUE .)
    GE              reduce using rule 54 (literal -> TRUE .)
    THIS            reduce using rule 54 (literal -> TRUE .)
    SUPER           reduce using rule 54 (literal -> TRUE .)
    (               reduce using rule 54 (literal -> TRUE .)
    NEW             reduce using rule 54 (literal -> TRUE .)
    INC             reduce using rule 54 (literal -> TRUE .)
    DEC             reduce using rule 54 (literal -> TRUE .)
    !               reduce using rule 54 (literal -> TRUE .)
    INT_CONST       reduce using rule 54 (literal -> TRUE .)
    FLOAT_CONST     reduce using rule 54 (literal -> TRUE .)
    STRING_CONST    reduce using rule 54 (literal -> TRUE .)
    NULL            reduce using rule 54 (literal -> TRUE .)
    TRUE            reduce using rule 54 (literal -> TRUE .)
    FALSE           reduce using rule 54 (literal -> TRUE .)
    ID              reduce using rule 54 (literal -> TRUE .)
    }               reduce using rule 54 (literal -> TRUE .)
    IF              reduce using rule 54 (literal -> TRUE .)
    WHILE           reduce using rule 54 (literal -> TRUE .)
    FOR             reduce using rule 54 (literal -> TRUE .)
    RETURN          reduce using rule 54 (literal -> TRUE .)
    BREAK           reduce using rule 54 (literal -> TRUE .)
    CONTINUE        reduce using rule 54 (literal -> TRUE .)
    {               reduce using rule 54 (literal -> TRUE .)
    INT             reduce using rule 54 (literal -> TRUE .)
    FLOAT           reduce using rule 54 (literal -> TRUE .)
    BOOLEAN         reduce using rule 54 (literal -> TRUE .)
    ELSE            reduce using rule 54 (literal -> TRUE .)
    ;               reduce using rule 54 (literal -> TRUE .)
    )               reduce using rule 54 (literal -> TRUE .)
    ]               reduce using rule 54 (literal -> TRUE .)
    ,               reduce using rule 54 (literal -> TRUE .)


state 87

    (38) stmt -> IF . ( expr ) stmt
    (39) stmt -> IF . ( expr ) stmt ELSE stmt

    (               shift and go to state 122


state 88

    (55) literal -> FALSE .

    .               reduce using rule 55 (literal -> FALSE .)
    [               reduce using rule 55 (literal -> FALSE .)
    +               reduce using rule 55 (literal -> FALSE .)
    -               reduce using rule 55 (literal -> FALSE .)
    *               reduce using rule 55 (literal -> FALSE .)
    /               reduce using rule 55 (literal -> FALSE .)
    AND             reduce using rule 55 (literal -> FALSE .)
    OR              reduce using rule 55 (literal -> FALSE .)
    EQL             reduce using rule 55 (literal -> FALSE .)
    UNEQL           reduce using rule 55 (literal -> FALSE .)
    <               reduce using rule 55 (literal -> FALSE .)
    >               reduce using rule 55 (literal -> FALSE .)
    LE              reduce using rule 55 (literal -> FALSE .)
    GE              reduce using rule 55 (literal -> FALSE .)
    THIS            reduce using rule 55 (literal -> FALSE .)
    SUPER           reduce using rule 55 (literal -> FALSE .)
    (               reduce using rule 55 (literal -> FALSE .)
    NEW             reduce using rule 55 (literal -> FALSE .)
    INC             reduce using rule 55 (literal -> FALSE .)
    DEC             reduce using rule 55 (literal -> FALSE .)
    !               reduce using rule 55 (literal -> FALSE .)
    INT_CONST       reduce using rule 55 (literal -> FALSE .)
    FLOAT_CONST     reduce using rule 55 (literal -> FALSE .)
    STRING_CONST    reduce using rule 55 (literal -> FALSE .)
    NULL            reduce using rule 55 (literal -> FALSE .)
    TRUE            reduce using rule 55 (literal -> FALSE .)
    FALSE           reduce using rule 55 (literal -> FALSE .)
    ID              reduce using rule 55 (literal -> FALSE .)
    }               reduce using rule 55 (literal -> FALSE .)
    IF              reduce using rule 55 (literal -> FALSE .)
    WHILE           reduce using rule 55 (literal -> FALSE .)
    FOR             reduce using rule 55 (literal -> FALSE .)
    RETURN          reduce using rule 55 (literal -> FALSE .)
    BREAK           reduce using rule 55 (literal -> FALSE .)
    CONTINUE        reduce using rule 55 (literal -> FALSE .)
    {               reduce using rule 55 (literal -> FALSE .)
    INT             reduce using rule 55 (literal -> FALSE .)
    FLOAT           reduce using rule 55 (literal -> FALSE .)
    BOOLEAN         reduce using rule 55 (literal -> FALSE .)
    ELSE            reduce using rule 55 (literal -> FALSE .)
    ;               reduce using rule 55 (literal -> FALSE .)
    )               reduce using rule 55 (literal -> FALSE .)
    ]               reduce using rule 55 (literal -> FALSE .)
    ,               reduce using rule 55 (literal -> FALSE .)


state 89

    (47) stmt -> var_decl .

    }               reduce using rule 47 (stmt -> var_decl .)
    IF              reduce using rule 47 (stmt -> var_decl .)
    WHILE           reduce using rule 47 (stmt -> var_decl .)
    FOR             reduce using rule 47 (stmt -> var_decl .)
    RETURN          reduce using rule 47 (stmt -> var_decl .)
    BREAK           reduce using rule 47 (stmt -> var_decl .)
    CONTINUE        reduce using rule 47 (stmt -> var_decl .)
    {               reduce using rule 47 (stmt -> var_decl .)
    INC             reduce using rule 47 (stmt -> var_decl .)
    DEC             reduce using rule 47 (stmt -> var_decl .)
    INT             reduce using rule 47 (stmt -> var_decl .)
    FLOAT           reduce using rule 47 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 47 (stmt -> var_decl .)
    ID              reduce using rule 47 (stmt -> var_decl .)
    THIS            reduce using rule 47 (stmt -> var_decl .)
    SUPER           reduce using rule 47 (stmt -> var_decl .)
    (               reduce using rule 47 (stmt -> var_decl .)
    NEW             reduce using rule 47 (stmt -> var_decl .)
    INT_CONST       reduce using rule 47 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 47 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 47 (stmt -> var_decl .)
    NULL            reduce using rule 47 (stmt -> var_decl .)
    TRUE            reduce using rule 47 (stmt -> var_decl .)
    FALSE           reduce using rule 47 (stmt -> var_decl .)
    ELSE            reduce using rule 47 (stmt -> var_decl .)


state 90

    (44) stmt -> BREAK .

    }               reduce using rule 44 (stmt -> BREAK .)
    IF              reduce using rule 44 (stmt -> BREAK .)
    WHILE           reduce using rule 44 (stmt -> BREAK .)
    FOR             reduce using rule 44 (stmt -> BREAK .)
    RETURN          reduce using rule 44 (stmt -> BREAK .)
    BREAK           reduce using rule 44 (stmt -> BREAK .)
    CONTINUE        reduce using rule 44 (stmt -> BREAK .)
    {               reduce using rule 44 (stmt -> BREAK .)
    INC             reduce using rule 44 (stmt -> BREAK .)
    DEC             reduce using rule 44 (stmt -> BREAK .)
    INT             reduce using rule 44 (stmt -> BREAK .)
    FLOAT           reduce using rule 44 (stmt -> BREAK .)
    BOOLEAN         reduce using rule 44 (stmt -> BREAK .)
    ID              reduce using rule 44 (stmt -> BREAK .)
    THIS            reduce using rule 44 (stmt -> BREAK .)
    SUPER           reduce using rule 44 (stmt -> BREAK .)
    (               reduce using rule 44 (stmt -> BREAK .)
    NEW             reduce using rule 44 (stmt -> BREAK .)
    INT_CONST       reduce using rule 44 (stmt -> BREAK .)
    FLOAT_CONST     reduce using rule 44 (stmt -> BREAK .)
    STRING_CONST    reduce using rule 44 (stmt -> BREAK .)
    NULL            reduce using rule 44 (stmt -> BREAK .)
    TRUE            reduce using rule 44 (stmt -> BREAK .)
    FALSE           reduce using rule 44 (stmt -> BREAK .)
    ELSE            reduce using rule 44 (stmt -> BREAK .)


state 91

    (45) stmt -> CONTINUE .

    }               reduce using rule 45 (stmt -> CONTINUE .)
    IF              reduce using rule 45 (stmt -> CONTINUE .)
    WHILE           reduce using rule 45 (stmt -> CONTINUE .)
    FOR             reduce using rule 45 (stmt -> CONTINUE .)
    RETURN          reduce using rule 45 (stmt -> CONTINUE .)
    BREAK           reduce using rule 45 (stmt -> CONTINUE .)
    CONTINUE        reduce using rule 45 (stmt -> CONTINUE .)
    {               reduce using rule 45 (stmt -> CONTINUE .)
    INC             reduce using rule 45 (stmt -> CONTINUE .)
    DEC             reduce using rule 45 (stmt -> CONTINUE .)
    INT             reduce using rule 45 (stmt -> CONTINUE .)
    FLOAT           reduce using rule 45 (stmt -> CONTINUE .)
    BOOLEAN         reduce using rule 45 (stmt -> CONTINUE .)
    ID              reduce using rule 45 (stmt -> CONTINUE .)
    THIS            reduce using rule 45 (stmt -> CONTINUE .)
    SUPER           reduce using rule 45 (stmt -> CONTINUE .)
    (               reduce using rule 45 (stmt -> CONTINUE .)
    NEW             reduce using rule 45 (stmt -> CONTINUE .)
    INT_CONST       reduce using rule 45 (stmt -> CONTINUE .)
    FLOAT_CONST     reduce using rule 45 (stmt -> CONTINUE .)
    STRING_CONST    reduce using rule 45 (stmt -> CONTINUE .)
    NULL            reduce using rule 45 (stmt -> CONTINUE .)
    TRUE            reduce using rule 45 (stmt -> CONTINUE .)
    FALSE           reduce using rule 45 (stmt -> CONTINUE .)
    ELSE            reduce using rule 45 (stmt -> CONTINUE .)


state 92

    (79) assign -> lhs . = expr
    (80) assign -> lhs . INC
    (82) assign -> lhs . DEC
    (61) primary -> lhs .

    =               shift and go to state 123
    INC             shift and go to state 125
    DEC             shift and go to state 124
    .               reduce using rule 61 (primary -> lhs .)
    [               reduce using rule 61 (primary -> lhs .)


state 93

    (35) block -> { stmts } .

    }               reduce using rule 35 (block -> { stmts } .)
    IF              reduce using rule 35 (block -> { stmts } .)
    WHILE           reduce using rule 35 (block -> { stmts } .)
    FOR             reduce using rule 35 (block -> { stmts } .)
    RETURN          reduce using rule 35 (block -> { stmts } .)
    BREAK           reduce using rule 35 (block -> { stmts } .)
    CONTINUE        reduce using rule 35 (block -> { stmts } .)
    {               reduce using rule 35 (block -> { stmts } .)
    INC             reduce using rule 35 (block -> { stmts } .)
    DEC             reduce using rule 35 (block -> { stmts } .)
    INT             reduce using rule 35 (block -> { stmts } .)
    FLOAT           reduce using rule 35 (block -> { stmts } .)
    BOOLEAN         reduce using rule 35 (block -> { stmts } .)
    ID              reduce using rule 35 (block -> { stmts } .)
    THIS            reduce using rule 35 (block -> { stmts } .)
    SUPER           reduce using rule 35 (block -> { stmts } .)
    (               reduce using rule 35 (block -> { stmts } .)
    NEW             reduce using rule 35 (block -> { stmts } .)
    INT_CONST       reduce using rule 35 (block -> { stmts } .)
    FLOAT_CONST     reduce using rule 35 (block -> { stmts } .)
    STRING_CONST    reduce using rule 35 (block -> { stmts } .)
    NULL            reduce using rule 35 (block -> { stmts } .)
    TRUE            reduce using rule 35 (block -> { stmts } .)
    FALSE           reduce using rule 35 (block -> { stmts } .)
    ELSE            reduce using rule 35 (block -> { stmts } .)
    PUBLIC          reduce using rule 35 (block -> { stmts } .)
    PRIVATE         reduce using rule 35 (block -> { stmts } .)
    STATIC          reduce using rule 35 (block -> { stmts } .)


state 94

    (103) stmt_expr -> assign .

    }               reduce using rule 103 (stmt_expr -> assign .)
    IF              reduce using rule 103 (stmt_expr -> assign .)
    WHILE           reduce using rule 103 (stmt_expr -> assign .)
    FOR             reduce using rule 103 (stmt_expr -> assign .)
    RETURN          reduce using rule 103 (stmt_expr -> assign .)
    BREAK           reduce using rule 103 (stmt_expr -> assign .)
    CONTINUE        reduce using rule 103 (stmt_expr -> assign .)
    {               reduce using rule 103 (stmt_expr -> assign .)
    INC             reduce using rule 103 (stmt_expr -> assign .)
    DEC             reduce using rule 103 (stmt_expr -> assign .)
    INT             reduce using rule 103 (stmt_expr -> assign .)
    FLOAT           reduce using rule 103 (stmt_expr -> assign .)
    BOOLEAN         reduce using rule 103 (stmt_expr -> assign .)
    ID              reduce using rule 103 (stmt_expr -> assign .)
    THIS            reduce using rule 103 (stmt_expr -> assign .)
    SUPER           reduce using rule 103 (stmt_expr -> assign .)
    (               reduce using rule 103 (stmt_expr -> assign .)
    NEW             reduce using rule 103 (stmt_expr -> assign .)
    INT_CONST       reduce using rule 103 (stmt_expr -> assign .)
    FLOAT_CONST     reduce using rule 103 (stmt_expr -> assign .)
    STRING_CONST    reduce using rule 103 (stmt_expr -> assign .)
    NULL            reduce using rule 103 (stmt_expr -> assign .)
    TRUE            reduce using rule 103 (stmt_expr -> assign .)
    FALSE           reduce using rule 103 (stmt_expr -> assign .)
    ELSE            reduce using rule 103 (stmt_expr -> assign .)
    ;               reduce using rule 103 (stmt_expr -> assign .)
    )               reduce using rule 103 (stmt_expr -> assign .)


state 95

    (46) stmt -> block .

    }               reduce using rule 46 (stmt -> block .)
    IF              reduce using rule 46 (stmt -> block .)
    WHILE           reduce using rule 46 (stmt -> block .)
    FOR             reduce using rule 46 (stmt -> block .)
    RETURN          reduce using rule 46 (stmt -> block .)
    BREAK           reduce using rule 46 (stmt -> block .)
    CONTINUE        reduce using rule 46 (stmt -> block .)
    {               reduce using rule 46 (stmt -> block .)
    INC             reduce using rule 46 (stmt -> block .)
    DEC             reduce using rule 46 (stmt -> block .)
    INT             reduce using rule 46 (stmt -> block .)
    FLOAT           reduce using rule 46 (stmt -> block .)
    BOOLEAN         reduce using rule 46 (stmt -> block .)
    ID              reduce using rule 46 (stmt -> block .)
    THIS            reduce using rule 46 (stmt -> block .)
    SUPER           reduce using rule 46 (stmt -> block .)
    (               reduce using rule 46 (stmt -> block .)
    NEW             reduce using rule 46 (stmt -> block .)
    INT_CONST       reduce using rule 46 (stmt -> block .)
    FLOAT_CONST     reduce using rule 46 (stmt -> block .)
    STRING_CONST    reduce using rule 46 (stmt -> block .)
    NULL            reduce using rule 46 (stmt -> block .)
    TRUE            reduce using rule 46 (stmt -> block .)
    FALSE           reduce using rule 46 (stmt -> block .)
    ELSE            reduce using rule 46 (stmt -> block .)


state 96

    (81) assign -> INC . lhs
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (72) method_invocation -> . field_access ( have_arguments )

    ID              shift and go to state 109
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 107
    primary                        shift and go to state 67
    literal                        shift and go to state 78
    lhs                            shift and go to state 126
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72

state 97

    (27) method_decl -> modifier ( all_type ) ID ( ) block .

    }               reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    (               reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    ID              reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    INT             reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    STATIC          reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)


state 98

    (26) method_decl -> modifier ( all_type ) ID ( formals ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 127

state 99

    (75) expr -> new_array .
    (84) new_array -> new_array . [ ]

    +               reduce using rule 75 (expr -> new_array .)
    -               reduce using rule 75 (expr -> new_array .)
    *               reduce using rule 75 (expr -> new_array .)
    /               reduce using rule 75 (expr -> new_array .)
    AND             reduce using rule 75 (expr -> new_array .)
    OR              reduce using rule 75 (expr -> new_array .)
    EQL             reduce using rule 75 (expr -> new_array .)
    UNEQL           reduce using rule 75 (expr -> new_array .)
    <               reduce using rule 75 (expr -> new_array .)
    >               reduce using rule 75 (expr -> new_array .)
    LE              reduce using rule 75 (expr -> new_array .)
    GE              reduce using rule 75 (expr -> new_array .)
    THIS            reduce using rule 75 (expr -> new_array .)
    SUPER           reduce using rule 75 (expr -> new_array .)
    (               reduce using rule 75 (expr -> new_array .)
    NEW             reduce using rule 75 (expr -> new_array .)
    INC             reduce using rule 75 (expr -> new_array .)
    DEC             reduce using rule 75 (expr -> new_array .)
    !               reduce using rule 75 (expr -> new_array .)
    INT_CONST       reduce using rule 75 (expr -> new_array .)
    FLOAT_CONST     reduce using rule 75 (expr -> new_array .)
    STRING_CONST    reduce using rule 75 (expr -> new_array .)
    NULL            reduce using rule 75 (expr -> new_array .)
    TRUE            reduce using rule 75 (expr -> new_array .)
    FALSE           reduce using rule 75 (expr -> new_array .)
    ID              reduce using rule 75 (expr -> new_array .)
    }               reduce using rule 75 (expr -> new_array .)
    IF              reduce using rule 75 (expr -> new_array .)
    WHILE           reduce using rule 75 (expr -> new_array .)
    FOR             reduce using rule 75 (expr -> new_array .)
    RETURN          reduce using rule 75 (expr -> new_array .)
    BREAK           reduce using rule 75 (expr -> new_array .)
    CONTINUE        reduce using rule 75 (expr -> new_array .)
    {               reduce using rule 75 (expr -> new_array .)
    INT             reduce using rule 75 (expr -> new_array .)
    FLOAT           reduce using rule 75 (expr -> new_array .)
    BOOLEAN         reduce using rule 75 (expr -> new_array .)
    ELSE            reduce using rule 75 (expr -> new_array .)
    )               reduce using rule 75 (expr -> new_array .)
    ]               reduce using rule 75 (expr -> new_array .)
    ,               reduce using rule 75 (expr -> new_array .)
    ;               reduce using rule 75 (expr -> new_array .)
    [               shift and go to state 128


state 100

    (73) expr -> primary .
    (69) field_access -> primary . . ID
    (71) array_access -> primary . [ expr ]

    +               reduce using rule 73 (expr -> primary .)
    -               reduce using rule 73 (expr -> primary .)
    *               reduce using rule 73 (expr -> primary .)
    /               reduce using rule 73 (expr -> primary .)
    AND             reduce using rule 73 (expr -> primary .)
    OR              reduce using rule 73 (expr -> primary .)
    EQL             reduce using rule 73 (expr -> primary .)
    UNEQL           reduce using rule 73 (expr -> primary .)
    <               reduce using rule 73 (expr -> primary .)
    >               reduce using rule 73 (expr -> primary .)
    LE              reduce using rule 73 (expr -> primary .)
    GE              reduce using rule 73 (expr -> primary .)
    THIS            reduce using rule 73 (expr -> primary .)
    SUPER           reduce using rule 73 (expr -> primary .)
    (               reduce using rule 73 (expr -> primary .)
    NEW             reduce using rule 73 (expr -> primary .)
    INC             reduce using rule 73 (expr -> primary .)
    DEC             reduce using rule 73 (expr -> primary .)
    !               reduce using rule 73 (expr -> primary .)
    INT_CONST       reduce using rule 73 (expr -> primary .)
    FLOAT_CONST     reduce using rule 73 (expr -> primary .)
    STRING_CONST    reduce using rule 73 (expr -> primary .)
    NULL            reduce using rule 73 (expr -> primary .)
    TRUE            reduce using rule 73 (expr -> primary .)
    FALSE           reduce using rule 73 (expr -> primary .)
    ID              reduce using rule 73 (expr -> primary .)
    }               reduce using rule 73 (expr -> primary .)
    IF              reduce using rule 73 (expr -> primary .)
    WHILE           reduce using rule 73 (expr -> primary .)
    FOR             reduce using rule 73 (expr -> primary .)
    RETURN          reduce using rule 73 (expr -> primary .)
    BREAK           reduce using rule 73 (expr -> primary .)
    CONTINUE        reduce using rule 73 (expr -> primary .)
    {               reduce using rule 73 (expr -> primary .)
    INT             reduce using rule 73 (expr -> primary .)
    FLOAT           reduce using rule 73 (expr -> primary .)
    BOOLEAN         reduce using rule 73 (expr -> primary .)
    ELSE            reduce using rule 73 (expr -> primary .)
    )               reduce using rule 73 (expr -> primary .)
    ]               reduce using rule 73 (expr -> primary .)
    ,               reduce using rule 73 (expr -> primary .)
    ;               reduce using rule 73 (expr -> primary .)
    .               shift and go to state 114
    [               shift and go to state 115


state 101

    (78) expr -> unary_op . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 129
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 102

    (60) primary -> NEW . ID ( have_arguments )
    (87) new_array_temp -> NEW . type [ expr ]
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    ID              shift and go to state 131
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27

    type                           shift and go to state 130

state 103

    (102) unary_op -> ! .

    THIS            reduce using rule 102 (unary_op -> ! .)
    SUPER           reduce using rule 102 (unary_op -> ! .)
    (               reduce using rule 102 (unary_op -> ! .)
    NEW             reduce using rule 102 (unary_op -> ! .)
    INC             reduce using rule 102 (unary_op -> ! .)
    DEC             reduce using rule 102 (unary_op -> ! .)
    +               reduce using rule 102 (unary_op -> ! .)
    -               reduce using rule 102 (unary_op -> ! .)
    !               reduce using rule 102 (unary_op -> ! .)
    INT_CONST       reduce using rule 102 (unary_op -> ! .)
    FLOAT_CONST     reduce using rule 102 (unary_op -> ! .)
    STRING_CONST    reduce using rule 102 (unary_op -> ! .)
    NULL            reduce using rule 102 (unary_op -> ! .)
    TRUE            reduce using rule 102 (unary_op -> ! .)
    FALSE           reduce using rule 102 (unary_op -> ! .)
    ID              reduce using rule 102 (unary_op -> ! .)


state 104

    (100) unary_op -> + .

    THIS            reduce using rule 100 (unary_op -> + .)
    SUPER           reduce using rule 100 (unary_op -> + .)
    (               reduce using rule 100 (unary_op -> + .)
    NEW             reduce using rule 100 (unary_op -> + .)
    INC             reduce using rule 100 (unary_op -> + .)
    DEC             reduce using rule 100 (unary_op -> + .)
    +               reduce using rule 100 (unary_op -> + .)
    -               reduce using rule 100 (unary_op -> + .)
    !               reduce using rule 100 (unary_op -> + .)
    INT_CONST       reduce using rule 100 (unary_op -> + .)
    FLOAT_CONST     reduce using rule 100 (unary_op -> + .)
    STRING_CONST    reduce using rule 100 (unary_op -> + .)
    NULL            reduce using rule 100 (unary_op -> + .)
    TRUE            reduce using rule 100 (unary_op -> + .)
    FALSE           reduce using rule 100 (unary_op -> + .)
    ID              reduce using rule 100 (unary_op -> + .)


state 105

    (101) unary_op -> - .

    THIS            reduce using rule 101 (unary_op -> - .)
    SUPER           reduce using rule 101 (unary_op -> - .)
    (               reduce using rule 101 (unary_op -> - .)
    NEW             reduce using rule 101 (unary_op -> - .)
    INC             reduce using rule 101 (unary_op -> - .)
    DEC             reduce using rule 101 (unary_op -> - .)
    +               reduce using rule 101 (unary_op -> - .)
    -               reduce using rule 101 (unary_op -> - .)
    !               reduce using rule 101 (unary_op -> - .)
    INT_CONST       reduce using rule 101 (unary_op -> - .)
    FLOAT_CONST     reduce using rule 101 (unary_op -> - .)
    STRING_CONST    reduce using rule 101 (unary_op -> - .)
    NULL            reduce using rule 101 (unary_op -> - .)
    TRUE            reduce using rule 101 (unary_op -> - .)
    FALSE           reduce using rule 101 (unary_op -> - .)
    ID              reduce using rule 101 (unary_op -> - .)


state 106

    (62) primary -> method_invocation .

    .               reduce using rule 62 (primary -> method_invocation .)
    [               reduce using rule 62 (primary -> method_invocation .)
    )               reduce using rule 62 (primary -> method_invocation .)
    +               reduce using rule 62 (primary -> method_invocation .)
    -               reduce using rule 62 (primary -> method_invocation .)
    *               reduce using rule 62 (primary -> method_invocation .)
    /               reduce using rule 62 (primary -> method_invocation .)
    AND             reduce using rule 62 (primary -> method_invocation .)
    OR              reduce using rule 62 (primary -> method_invocation .)
    EQL             reduce using rule 62 (primary -> method_invocation .)
    UNEQL           reduce using rule 62 (primary -> method_invocation .)
    <               reduce using rule 62 (primary -> method_invocation .)
    >               reduce using rule 62 (primary -> method_invocation .)
    LE              reduce using rule 62 (primary -> method_invocation .)
    GE              reduce using rule 62 (primary -> method_invocation .)
    ]               reduce using rule 62 (primary -> method_invocation .)
    THIS            reduce using rule 62 (primary -> method_invocation .)
    SUPER           reduce using rule 62 (primary -> method_invocation .)
    (               reduce using rule 62 (primary -> method_invocation .)
    NEW             reduce using rule 62 (primary -> method_invocation .)
    INC             reduce using rule 62 (primary -> method_invocation .)
    DEC             reduce using rule 62 (primary -> method_invocation .)
    !               reduce using rule 62 (primary -> method_invocation .)
    INT_CONST       reduce using rule 62 (primary -> method_invocation .)
    FLOAT_CONST     reduce using rule 62 (primary -> method_invocation .)
    STRING_CONST    reduce using rule 62 (primary -> method_invocation .)
    NULL            reduce using rule 62 (primary -> method_invocation .)
    TRUE            reduce using rule 62 (primary -> method_invocation .)
    FALSE           reduce using rule 62 (primary -> method_invocation .)
    ID              reduce using rule 62 (primary -> method_invocation .)
    }               reduce using rule 62 (primary -> method_invocation .)
    IF              reduce using rule 62 (primary -> method_invocation .)
    WHILE           reduce using rule 62 (primary -> method_invocation .)
    FOR             reduce using rule 62 (primary -> method_invocation .)
    RETURN          reduce using rule 62 (primary -> method_invocation .)
    BREAK           reduce using rule 62 (primary -> method_invocation .)
    CONTINUE        reduce using rule 62 (primary -> method_invocation .)
    {               reduce using rule 62 (primary -> method_invocation .)
    INT             reduce using rule 62 (primary -> method_invocation .)
    FLOAT           reduce using rule 62 (primary -> method_invocation .)
    BOOLEAN         reduce using rule 62 (primary -> method_invocation .)
    ELSE            reduce using rule 62 (primary -> method_invocation .)
    ,               reduce using rule 62 (primary -> method_invocation .)
    ;               reduce using rule 62 (primary -> method_invocation .)


state 107

    (67) lhs -> field_access .
    (72) method_invocation -> field_access . ( have_arguments )

  ! shift/reduce conflict for ( resolved as shift
    =               reduce using rule 67 (lhs -> field_access .)
    INC             reduce using rule 67 (lhs -> field_access .)
    DEC             reduce using rule 67 (lhs -> field_access .)
    .               reduce using rule 67 (lhs -> field_access .)
    [               reduce using rule 67 (lhs -> field_access .)
    +               reduce using rule 67 (lhs -> field_access .)
    -               reduce using rule 67 (lhs -> field_access .)
    *               reduce using rule 67 (lhs -> field_access .)
    /               reduce using rule 67 (lhs -> field_access .)
    AND             reduce using rule 67 (lhs -> field_access .)
    OR              reduce using rule 67 (lhs -> field_access .)
    EQL             reduce using rule 67 (lhs -> field_access .)
    UNEQL           reduce using rule 67 (lhs -> field_access .)
    <               reduce using rule 67 (lhs -> field_access .)
    >               reduce using rule 67 (lhs -> field_access .)
    LE              reduce using rule 67 (lhs -> field_access .)
    GE              reduce using rule 67 (lhs -> field_access .)
    THIS            reduce using rule 67 (lhs -> field_access .)
    SUPER           reduce using rule 67 (lhs -> field_access .)
    NEW             reduce using rule 67 (lhs -> field_access .)
    !               reduce using rule 67 (lhs -> field_access .)
    INT_CONST       reduce using rule 67 (lhs -> field_access .)
    FLOAT_CONST     reduce using rule 67 (lhs -> field_access .)
    STRING_CONST    reduce using rule 67 (lhs -> field_access .)
    NULL            reduce using rule 67 (lhs -> field_access .)
    TRUE            reduce using rule 67 (lhs -> field_access .)
    FALSE           reduce using rule 67 (lhs -> field_access .)
    ID              reduce using rule 67 (lhs -> field_access .)
    }               reduce using rule 67 (lhs -> field_access .)
    IF              reduce using rule 67 (lhs -> field_access .)
    WHILE           reduce using rule 67 (lhs -> field_access .)
    FOR             reduce using rule 67 (lhs -> field_access .)
    RETURN          reduce using rule 67 (lhs -> field_access .)
    BREAK           reduce using rule 67 (lhs -> field_access .)
    CONTINUE        reduce using rule 67 (lhs -> field_access .)
    {               reduce using rule 67 (lhs -> field_access .)
    INT             reduce using rule 67 (lhs -> field_access .)
    FLOAT           reduce using rule 67 (lhs -> field_access .)
    BOOLEAN         reduce using rule 67 (lhs -> field_access .)
    ELSE            reduce using rule 67 (lhs -> field_access .)
    )               reduce using rule 67 (lhs -> field_access .)
    ]               reduce using rule 67 (lhs -> field_access .)
    ,               reduce using rule 67 (lhs -> field_access .)
    ;               reduce using rule 67 (lhs -> field_access .)
    (               shift and go to state 120

  ! (               [ reduce using rule 67 (lhs -> field_access .) ]


state 108

    (85) new_array -> new_array_temp .
    (86) new_array_temp -> new_array_temp . [ expr ]

  ! shift/reduce conflict for [ resolved as shift
    ]               reduce using rule 85 (new_array -> new_array_temp .)
    +               reduce using rule 85 (new_array -> new_array_temp .)
    -               reduce using rule 85 (new_array -> new_array_temp .)
    *               reduce using rule 85 (new_array -> new_array_temp .)
    /               reduce using rule 85 (new_array -> new_array_temp .)
    AND             reduce using rule 85 (new_array -> new_array_temp .)
    OR              reduce using rule 85 (new_array -> new_array_temp .)
    EQL             reduce using rule 85 (new_array -> new_array_temp .)
    UNEQL           reduce using rule 85 (new_array -> new_array_temp .)
    <               reduce using rule 85 (new_array -> new_array_temp .)
    >               reduce using rule 85 (new_array -> new_array_temp .)
    LE              reduce using rule 85 (new_array -> new_array_temp .)
    GE              reduce using rule 85 (new_array -> new_array_temp .)
    )               reduce using rule 85 (new_array -> new_array_temp .)
    ;               reduce using rule 85 (new_array -> new_array_temp .)
    ,               reduce using rule 85 (new_array -> new_array_temp .)
    THIS            reduce using rule 85 (new_array -> new_array_temp .)
    SUPER           reduce using rule 85 (new_array -> new_array_temp .)
    (               reduce using rule 85 (new_array -> new_array_temp .)
    NEW             reduce using rule 85 (new_array -> new_array_temp .)
    INC             reduce using rule 85 (new_array -> new_array_temp .)
    DEC             reduce using rule 85 (new_array -> new_array_temp .)
    !               reduce using rule 85 (new_array -> new_array_temp .)
    INT_CONST       reduce using rule 85 (new_array -> new_array_temp .)
    FLOAT_CONST     reduce using rule 85 (new_array -> new_array_temp .)
    STRING_CONST    reduce using rule 85 (new_array -> new_array_temp .)
    NULL            reduce using rule 85 (new_array -> new_array_temp .)
    TRUE            reduce using rule 85 (new_array -> new_array_temp .)
    FALSE           reduce using rule 85 (new_array -> new_array_temp .)
    ID              reduce using rule 85 (new_array -> new_array_temp .)
    }               reduce using rule 85 (new_array -> new_array_temp .)
    IF              reduce using rule 85 (new_array -> new_array_temp .)
    WHILE           reduce using rule 85 (new_array -> new_array_temp .)
    FOR             reduce using rule 85 (new_array -> new_array_temp .)
    RETURN          reduce using rule 85 (new_array -> new_array_temp .)
    BREAK           reduce using rule 85 (new_array -> new_array_temp .)
    CONTINUE        reduce using rule 85 (new_array -> new_array_temp .)
    {               reduce using rule 85 (new_array -> new_array_temp .)
    INT             reduce using rule 85 (new_array -> new_array_temp .)
    FLOAT           reduce using rule 85 (new_array -> new_array_temp .)
    BOOLEAN         reduce using rule 85 (new_array -> new_array_temp .)
    ELSE            reduce using rule 85 (new_array -> new_array_temp .)
    [               shift and go to state 132

  ! [               [ reduce using rule 85 (new_array -> new_array_temp .) ]


state 109

    (70) field_access -> ID .

    (               reduce using rule 70 (field_access -> ID .)
    =               reduce using rule 70 (field_access -> ID .)
    INC             reduce using rule 70 (field_access -> ID .)
    DEC             reduce using rule 70 (field_access -> ID .)
    .               reduce using rule 70 (field_access -> ID .)
    [               reduce using rule 70 (field_access -> ID .)
    )               reduce using rule 70 (field_access -> ID .)
    +               reduce using rule 70 (field_access -> ID .)
    -               reduce using rule 70 (field_access -> ID .)
    *               reduce using rule 70 (field_access -> ID .)
    /               reduce using rule 70 (field_access -> ID .)
    AND             reduce using rule 70 (field_access -> ID .)
    OR              reduce using rule 70 (field_access -> ID .)
    EQL             reduce using rule 70 (field_access -> ID .)
    UNEQL           reduce using rule 70 (field_access -> ID .)
    <               reduce using rule 70 (field_access -> ID .)
    >               reduce using rule 70 (field_access -> ID .)
    LE              reduce using rule 70 (field_access -> ID .)
    GE              reduce using rule 70 (field_access -> ID .)
    THIS            reduce using rule 70 (field_access -> ID .)
    SUPER           reduce using rule 70 (field_access -> ID .)
    NEW             reduce using rule 70 (field_access -> ID .)
    !               reduce using rule 70 (field_access -> ID .)
    INT_CONST       reduce using rule 70 (field_access -> ID .)
    FLOAT_CONST     reduce using rule 70 (field_access -> ID .)
    STRING_CONST    reduce using rule 70 (field_access -> ID .)
    NULL            reduce using rule 70 (field_access -> ID .)
    TRUE            reduce using rule 70 (field_access -> ID .)
    FALSE           reduce using rule 70 (field_access -> ID .)
    ID              reduce using rule 70 (field_access -> ID .)
    }               reduce using rule 70 (field_access -> ID .)
    IF              reduce using rule 70 (field_access -> ID .)
    WHILE           reduce using rule 70 (field_access -> ID .)
    FOR             reduce using rule 70 (field_access -> ID .)
    RETURN          reduce using rule 70 (field_access -> ID .)
    BREAK           reduce using rule 70 (field_access -> ID .)
    CONTINUE        reduce using rule 70 (field_access -> ID .)
    {               reduce using rule 70 (field_access -> ID .)
    INT             reduce using rule 70 (field_access -> ID .)
    FLOAT           reduce using rule 70 (field_access -> ID .)
    BOOLEAN         reduce using rule 70 (field_access -> ID .)
    ELSE            reduce using rule 70 (field_access -> ID .)
    ]               reduce using rule 70 (field_access -> ID .)
    ,               reduce using rule 70 (field_access -> ID .)
    ;               reduce using rule 70 (field_access -> ID .)


state 110

    (49) exprs -> expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    THIS            reduce using rule 49 (exprs -> expr .)
    SUPER           reduce using rule 49 (exprs -> expr .)
    (               reduce using rule 49 (exprs -> expr .)
    NEW             reduce using rule 49 (exprs -> expr .)
    INC             reduce using rule 49 (exprs -> expr .)
    DEC             reduce using rule 49 (exprs -> expr .)
    !               reduce using rule 49 (exprs -> expr .)
    INT_CONST       reduce using rule 49 (exprs -> expr .)
    FLOAT_CONST     reduce using rule 49 (exprs -> expr .)
    STRING_CONST    reduce using rule 49 (exprs -> expr .)
    NULL            reduce using rule 49 (exprs -> expr .)
    TRUE            reduce using rule 49 (exprs -> expr .)
    FALSE           reduce using rule 49 (exprs -> expr .)
    ID              reduce using rule 49 (exprs -> expr .)
    }               reduce using rule 49 (exprs -> expr .)
    IF              reduce using rule 49 (exprs -> expr .)
    WHILE           reduce using rule 49 (exprs -> expr .)
    FOR             reduce using rule 49 (exprs -> expr .)
    RETURN          reduce using rule 49 (exprs -> expr .)
    BREAK           reduce using rule 49 (exprs -> expr .)
    CONTINUE        reduce using rule 49 (exprs -> expr .)
    {               reduce using rule 49 (exprs -> expr .)
    INT             reduce using rule 49 (exprs -> expr .)
    FLOAT           reduce using rule 49 (exprs -> expr .)
    BOOLEAN         reduce using rule 49 (exprs -> expr .)
    ELSE            reduce using rule 49 (exprs -> expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 49 (exprs -> expr .) ]
  ! -               [ reduce using rule 49 (exprs -> expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 111

    (42) stmt -> RETURN exprs .
    (48) exprs -> exprs . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    }               reduce using rule 42 (stmt -> RETURN exprs .)
    IF              reduce using rule 42 (stmt -> RETURN exprs .)
    WHILE           reduce using rule 42 (stmt -> RETURN exprs .)
    FOR             reduce using rule 42 (stmt -> RETURN exprs .)
    RETURN          reduce using rule 42 (stmt -> RETURN exprs .)
    BREAK           reduce using rule 42 (stmt -> RETURN exprs .)
    CONTINUE        reduce using rule 42 (stmt -> RETURN exprs .)
    {               reduce using rule 42 (stmt -> RETURN exprs .)
    INT             reduce using rule 42 (stmt -> RETURN exprs .)
    FLOAT           reduce using rule 42 (stmt -> RETURN exprs .)
    BOOLEAN         reduce using rule 42 (stmt -> RETURN exprs .)
    ELSE            reduce using rule 42 (stmt -> RETURN exprs .)
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

  ! INC             [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! DEC             [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! ID              [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! THIS            [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! SUPER           [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! (               [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! NEW             [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! INT_CONST       [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! FLOAT_CONST     [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! STRING_CONST    [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! NULL            [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! TRUE            [ reduce using rule 42 (stmt -> RETURN exprs .) ]
  ! FALSE           [ reduce using rule 42 (stmt -> RETURN exprs .) ]

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    expr                           shift and go to state 147
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 107
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 112

    (61) primary -> lhs .
    (79) assign -> lhs . = expr
    (80) assign -> lhs . INC
    (82) assign -> lhs . DEC

  ! shift/reduce conflict for INC resolved as shift
  ! shift/reduce conflict for DEC resolved as shift
    .               reduce using rule 61 (primary -> lhs .)
    [               reduce using rule 61 (primary -> lhs .)
    )               reduce using rule 61 (primary -> lhs .)
    +               reduce using rule 61 (primary -> lhs .)
    -               reduce using rule 61 (primary -> lhs .)
    *               reduce using rule 61 (primary -> lhs .)
    /               reduce using rule 61 (primary -> lhs .)
    AND             reduce using rule 61 (primary -> lhs .)
    OR              reduce using rule 61 (primary -> lhs .)
    EQL             reduce using rule 61 (primary -> lhs .)
    UNEQL           reduce using rule 61 (primary -> lhs .)
    <               reduce using rule 61 (primary -> lhs .)
    >               reduce using rule 61 (primary -> lhs .)
    LE              reduce using rule 61 (primary -> lhs .)
    GE              reduce using rule 61 (primary -> lhs .)
    ]               reduce using rule 61 (primary -> lhs .)
    THIS            reduce using rule 61 (primary -> lhs .)
    SUPER           reduce using rule 61 (primary -> lhs .)
    (               reduce using rule 61 (primary -> lhs .)
    NEW             reduce using rule 61 (primary -> lhs .)
    !               reduce using rule 61 (primary -> lhs .)
    INT_CONST       reduce using rule 61 (primary -> lhs .)
    FLOAT_CONST     reduce using rule 61 (primary -> lhs .)
    STRING_CONST    reduce using rule 61 (primary -> lhs .)
    NULL            reduce using rule 61 (primary -> lhs .)
    TRUE            reduce using rule 61 (primary -> lhs .)
    FALSE           reduce using rule 61 (primary -> lhs .)
    ID              reduce using rule 61 (primary -> lhs .)
    }               reduce using rule 61 (primary -> lhs .)
    IF              reduce using rule 61 (primary -> lhs .)
    WHILE           reduce using rule 61 (primary -> lhs .)
    FOR             reduce using rule 61 (primary -> lhs .)
    RETURN          reduce using rule 61 (primary -> lhs .)
    BREAK           reduce using rule 61 (primary -> lhs .)
    CONTINUE        reduce using rule 61 (primary -> lhs .)
    {               reduce using rule 61 (primary -> lhs .)
    INT             reduce using rule 61 (primary -> lhs .)
    FLOAT           reduce using rule 61 (primary -> lhs .)
    BOOLEAN         reduce using rule 61 (primary -> lhs .)
    ELSE            reduce using rule 61 (primary -> lhs .)
    ,               reduce using rule 61 (primary -> lhs .)
    ;               reduce using rule 61 (primary -> lhs .)
    =               shift and go to state 123
    INC             shift and go to state 125
    DEC             shift and go to state 124

  ! INC             [ reduce using rule 61 (primary -> lhs .) ]
  ! DEC             [ reduce using rule 61 (primary -> lhs .) ]


state 113

    (74) expr -> assign .

    +               reduce using rule 74 (expr -> assign .)
    -               reduce using rule 74 (expr -> assign .)
    *               reduce using rule 74 (expr -> assign .)
    /               reduce using rule 74 (expr -> assign .)
    AND             reduce using rule 74 (expr -> assign .)
    OR              reduce using rule 74 (expr -> assign .)
    EQL             reduce using rule 74 (expr -> assign .)
    UNEQL           reduce using rule 74 (expr -> assign .)
    <               reduce using rule 74 (expr -> assign .)
    >               reduce using rule 74 (expr -> assign .)
    LE              reduce using rule 74 (expr -> assign .)
    GE              reduce using rule 74 (expr -> assign .)
    THIS            reduce using rule 74 (expr -> assign .)
    SUPER           reduce using rule 74 (expr -> assign .)
    (               reduce using rule 74 (expr -> assign .)
    NEW             reduce using rule 74 (expr -> assign .)
    INC             reduce using rule 74 (expr -> assign .)
    DEC             reduce using rule 74 (expr -> assign .)
    !               reduce using rule 74 (expr -> assign .)
    INT_CONST       reduce using rule 74 (expr -> assign .)
    FLOAT_CONST     reduce using rule 74 (expr -> assign .)
    STRING_CONST    reduce using rule 74 (expr -> assign .)
    NULL            reduce using rule 74 (expr -> assign .)
    TRUE            reduce using rule 74 (expr -> assign .)
    FALSE           reduce using rule 74 (expr -> assign .)
    ID              reduce using rule 74 (expr -> assign .)
    }               reduce using rule 74 (expr -> assign .)
    IF              reduce using rule 74 (expr -> assign .)
    WHILE           reduce using rule 74 (expr -> assign .)
    FOR             reduce using rule 74 (expr -> assign .)
    RETURN          reduce using rule 74 (expr -> assign .)
    BREAK           reduce using rule 74 (expr -> assign .)
    CONTINUE        reduce using rule 74 (expr -> assign .)
    {               reduce using rule 74 (expr -> assign .)
    INT             reduce using rule 74 (expr -> assign .)
    FLOAT           reduce using rule 74 (expr -> assign .)
    BOOLEAN         reduce using rule 74 (expr -> assign .)
    ELSE            reduce using rule 74 (expr -> assign .)
    )               reduce using rule 74 (expr -> assign .)
    ]               reduce using rule 74 (expr -> assign .)
    ,               reduce using rule 74 (expr -> assign .)
    ;               reduce using rule 74 (expr -> assign .)


state 114

    (69) field_access -> primary . . ID

    ID              shift and go to state 148


state 115

    (71) array_access -> primary [ . expr ]
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 149
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 116

    (40) stmt -> WHILE ( . expr ) stmt
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 150
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 117

    (60) primary -> NEW ID . ( have_arguments )

    (               shift and go to state 151


state 118

    (83) assign -> DEC lhs .
    (61) primary -> lhs .

    +               reduce using rule 83 (assign -> DEC lhs .)
    -               reduce using rule 83 (assign -> DEC lhs .)
    *               reduce using rule 83 (assign -> DEC lhs .)
    /               reduce using rule 83 (assign -> DEC lhs .)
    AND             reduce using rule 83 (assign -> DEC lhs .)
    OR              reduce using rule 83 (assign -> DEC lhs .)
    EQL             reduce using rule 83 (assign -> DEC lhs .)
    UNEQL           reduce using rule 83 (assign -> DEC lhs .)
    <               reduce using rule 83 (assign -> DEC lhs .)
    >               reduce using rule 83 (assign -> DEC lhs .)
    LE              reduce using rule 83 (assign -> DEC lhs .)
    GE              reduce using rule 83 (assign -> DEC lhs .)
    THIS            reduce using rule 83 (assign -> DEC lhs .)
    SUPER           reduce using rule 83 (assign -> DEC lhs .)
    (               reduce using rule 83 (assign -> DEC lhs .)
    NEW             reduce using rule 83 (assign -> DEC lhs .)
    INC             reduce using rule 83 (assign -> DEC lhs .)
    DEC             reduce using rule 83 (assign -> DEC lhs .)
    !               reduce using rule 83 (assign -> DEC lhs .)
    INT_CONST       reduce using rule 83 (assign -> DEC lhs .)
    FLOAT_CONST     reduce using rule 83 (assign -> DEC lhs .)
    STRING_CONST    reduce using rule 83 (assign -> DEC lhs .)
    NULL            reduce using rule 83 (assign -> DEC lhs .)
    TRUE            reduce using rule 83 (assign -> DEC lhs .)
    FALSE           reduce using rule 83 (assign -> DEC lhs .)
    ID              reduce using rule 83 (assign -> DEC lhs .)
    }               reduce using rule 83 (assign -> DEC lhs .)
    IF              reduce using rule 83 (assign -> DEC lhs .)
    WHILE           reduce using rule 83 (assign -> DEC lhs .)
    FOR             reduce using rule 83 (assign -> DEC lhs .)
    RETURN          reduce using rule 83 (assign -> DEC lhs .)
    BREAK           reduce using rule 83 (assign -> DEC lhs .)
    CONTINUE        reduce using rule 83 (assign -> DEC lhs .)
    {               reduce using rule 83 (assign -> DEC lhs .)
    INT             reduce using rule 83 (assign -> DEC lhs .)
    FLOAT           reduce using rule 83 (assign -> DEC lhs .)
    BOOLEAN         reduce using rule 83 (assign -> DEC lhs .)
    ELSE            reduce using rule 83 (assign -> DEC lhs .)
    )               reduce using rule 83 (assign -> DEC lhs .)
    ,               reduce using rule 83 (assign -> DEC lhs .)
    ]               reduce using rule 83 (assign -> DEC lhs .)
    ;               reduce using rule 83 (assign -> DEC lhs .)
    .               reduce using rule 61 (primary -> lhs .)
    [               reduce using rule 61 (primary -> lhs .)


state 119

    (59) primary -> ( expr . )
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    )               shift and go to state 152
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 120

    (72) method_invocation -> field_access ( . have_arguments )
    (63) have_arguments -> . arguments
    (64) have_arguments -> . empty
    (65) arguments -> . arguments , expr
    (66) arguments -> . expr
    (105) empty -> .
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    )               reduce using rule 105 (empty -> .)
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    field_access                   shift and go to state 107
    new_array_temp                 shift and go to state 108
    have_arguments                 shift and go to state 155
    new_array                      shift and go to state 99
    expr                           shift and go to state 156
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    arguments                      shift and go to state 153
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113
    empty                          shift and go to state 154
    unary_op                       shift and go to state 101

state 121

    (41) stmt -> FOR ( . stmt_expr ; expr ; stmt_expr ) stmt
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    INC             shift and go to state 96
    DEC             shift and go to state 71
    ID              shift and go to state 109
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    primary                        shift and go to state 67
    stmt_expr                      shift and go to state 157
    literal                        shift and go to state 78
    lhs                            shift and go to state 92
    method_invocation              shift and go to state 79
    array_access                   shift and go to state 72
    assign                         shift and go to state 94

state 122

    (38) stmt -> IF ( . expr ) stmt
    (39) stmt -> IF ( . expr ) stmt ELSE stmt
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 158
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 123

    (79) assign -> lhs = . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 159
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 124

    (82) assign -> lhs DEC .

    +               reduce using rule 82 (assign -> lhs DEC .)
    -               reduce using rule 82 (assign -> lhs DEC .)
    *               reduce using rule 82 (assign -> lhs DEC .)
    /               reduce using rule 82 (assign -> lhs DEC .)
    AND             reduce using rule 82 (assign -> lhs DEC .)
    OR              reduce using rule 82 (assign -> lhs DEC .)
    EQL             reduce using rule 82 (assign -> lhs DEC .)
    UNEQL           reduce using rule 82 (assign -> lhs DEC .)
    <               reduce using rule 82 (assign -> lhs DEC .)
    >               reduce using rule 82 (assign -> lhs DEC .)
    LE              reduce using rule 82 (assign -> lhs DEC .)
    GE              reduce using rule 82 (assign -> lhs DEC .)
    THIS            reduce using rule 82 (assign -> lhs DEC .)
    SUPER           reduce using rule 82 (assign -> lhs DEC .)
    (               reduce using rule 82 (assign -> lhs DEC .)
    NEW             reduce using rule 82 (assign -> lhs DEC .)
    INC             reduce using rule 82 (assign -> lhs DEC .)
    DEC             reduce using rule 82 (assign -> lhs DEC .)
    !               reduce using rule 82 (assign -> lhs DEC .)
    INT_CONST       reduce using rule 82 (assign -> lhs DEC .)
    FLOAT_CONST     reduce using rule 82 (assign -> lhs DEC .)
    STRING_CONST    reduce using rule 82 (assign -> lhs DEC .)
    NULL            reduce using rule 82 (assign -> lhs DEC .)
    TRUE            reduce using rule 82 (assign -> lhs DEC .)
    FALSE           reduce using rule 82 (assign -> lhs DEC .)
    ID              reduce using rule 82 (assign -> lhs DEC .)
    }               reduce using rule 82 (assign -> lhs DEC .)
    IF              reduce using rule 82 (assign -> lhs DEC .)
    WHILE           reduce using rule 82 (assign -> lhs DEC .)
    FOR             reduce using rule 82 (assign -> lhs DEC .)
    RETURN          reduce using rule 82 (assign -> lhs DEC .)
    BREAK           reduce using rule 82 (assign -> lhs DEC .)
    CONTINUE        reduce using rule 82 (assign -> lhs DEC .)
    {               reduce using rule 82 (assign -> lhs DEC .)
    INT             reduce using rule 82 (assign -> lhs DEC .)
    FLOAT           reduce using rule 82 (assign -> lhs DEC .)
    BOOLEAN         reduce using rule 82 (assign -> lhs DEC .)
    ELSE            reduce using rule 82 (assign -> lhs DEC .)
    )               reduce using rule 82 (assign -> lhs DEC .)
    ,               reduce using rule 82 (assign -> lhs DEC .)
    ]               reduce using rule 82 (assign -> lhs DEC .)
    ;               reduce using rule 82 (assign -> lhs DEC .)


state 125

    (80) assign -> lhs INC .

    +               reduce using rule 80 (assign -> lhs INC .)
    -               reduce using rule 80 (assign -> lhs INC .)
    *               reduce using rule 80 (assign -> lhs INC .)
    /               reduce using rule 80 (assign -> lhs INC .)
    AND             reduce using rule 80 (assign -> lhs INC .)
    OR              reduce using rule 80 (assign -> lhs INC .)
    EQL             reduce using rule 80 (assign -> lhs INC .)
    UNEQL           reduce using rule 80 (assign -> lhs INC .)
    <               reduce using rule 80 (assign -> lhs INC .)
    >               reduce using rule 80 (assign -> lhs INC .)
    LE              reduce using rule 80 (assign -> lhs INC .)
    GE              reduce using rule 80 (assign -> lhs INC .)
    THIS            reduce using rule 80 (assign -> lhs INC .)
    SUPER           reduce using rule 80 (assign -> lhs INC .)
    (               reduce using rule 80 (assign -> lhs INC .)
    NEW             reduce using rule 80 (assign -> lhs INC .)
    INC             reduce using rule 80 (assign -> lhs INC .)
    DEC             reduce using rule 80 (assign -> lhs INC .)
    !               reduce using rule 80 (assign -> lhs INC .)
    INT_CONST       reduce using rule 80 (assign -> lhs INC .)
    FLOAT_CONST     reduce using rule 80 (assign -> lhs INC .)
    STRING_CONST    reduce using rule 80 (assign -> lhs INC .)
    NULL            reduce using rule 80 (assign -> lhs INC .)
    TRUE            reduce using rule 80 (assign -> lhs INC .)
    FALSE           reduce using rule 80 (assign -> lhs INC .)
    ID              reduce using rule 80 (assign -> lhs INC .)
    }               reduce using rule 80 (assign -> lhs INC .)
    IF              reduce using rule 80 (assign -> lhs INC .)
    WHILE           reduce using rule 80 (assign -> lhs INC .)
    FOR             reduce using rule 80 (assign -> lhs INC .)
    RETURN          reduce using rule 80 (assign -> lhs INC .)
    BREAK           reduce using rule 80 (assign -> lhs INC .)
    CONTINUE        reduce using rule 80 (assign -> lhs INC .)
    {               reduce using rule 80 (assign -> lhs INC .)
    INT             reduce using rule 80 (assign -> lhs INC .)
    FLOAT           reduce using rule 80 (assign -> lhs INC .)
    BOOLEAN         reduce using rule 80 (assign -> lhs INC .)
    ELSE            reduce using rule 80 (assign -> lhs INC .)
    )               reduce using rule 80 (assign -> lhs INC .)
    ,               reduce using rule 80 (assign -> lhs INC .)
    ]               reduce using rule 80 (assign -> lhs INC .)
    ;               reduce using rule 80 (assign -> lhs INC .)


state 126

    (81) assign -> INC lhs .
    (61) primary -> lhs .

    +               reduce using rule 81 (assign -> INC lhs .)
    -               reduce using rule 81 (assign -> INC lhs .)
    *               reduce using rule 81 (assign -> INC lhs .)
    /               reduce using rule 81 (assign -> INC lhs .)
    AND             reduce using rule 81 (assign -> INC lhs .)
    OR              reduce using rule 81 (assign -> INC lhs .)
    EQL             reduce using rule 81 (assign -> INC lhs .)
    UNEQL           reduce using rule 81 (assign -> INC lhs .)
    <               reduce using rule 81 (assign -> INC lhs .)
    >               reduce using rule 81 (assign -> INC lhs .)
    LE              reduce using rule 81 (assign -> INC lhs .)
    GE              reduce using rule 81 (assign -> INC lhs .)
    THIS            reduce using rule 81 (assign -> INC lhs .)
    SUPER           reduce using rule 81 (assign -> INC lhs .)
    (               reduce using rule 81 (assign -> INC lhs .)
    NEW             reduce using rule 81 (assign -> INC lhs .)
    INC             reduce using rule 81 (assign -> INC lhs .)
    DEC             reduce using rule 81 (assign -> INC lhs .)
    !               reduce using rule 81 (assign -> INC lhs .)
    INT_CONST       reduce using rule 81 (assign -> INC lhs .)
    FLOAT_CONST     reduce using rule 81 (assign -> INC lhs .)
    STRING_CONST    reduce using rule 81 (assign -> INC lhs .)
    NULL            reduce using rule 81 (assign -> INC lhs .)
    TRUE            reduce using rule 81 (assign -> INC lhs .)
    FALSE           reduce using rule 81 (assign -> INC lhs .)
    ID              reduce using rule 81 (assign -> INC lhs .)
    }               reduce using rule 81 (assign -> INC lhs .)
    IF              reduce using rule 81 (assign -> INC lhs .)
    WHILE           reduce using rule 81 (assign -> INC lhs .)
    FOR             reduce using rule 81 (assign -> INC lhs .)
    RETURN          reduce using rule 81 (assign -> INC lhs .)
    BREAK           reduce using rule 81 (assign -> INC lhs .)
    CONTINUE        reduce using rule 81 (assign -> INC lhs .)
    {               reduce using rule 81 (assign -> INC lhs .)
    INT             reduce using rule 81 (assign -> INC lhs .)
    FLOAT           reduce using rule 81 (assign -> INC lhs .)
    BOOLEAN         reduce using rule 81 (assign -> INC lhs .)
    ELSE            reduce using rule 81 (assign -> INC lhs .)
    )               reduce using rule 81 (assign -> INC lhs .)
    ,               reduce using rule 81 (assign -> INC lhs .)
    ]               reduce using rule 81 (assign -> INC lhs .)
    ;               reduce using rule 81 (assign -> INC lhs .)
    .               reduce using rule 61 (primary -> lhs .)
    [               reduce using rule 61 (primary -> lhs .)


state 127

    (26) method_decl -> modifier ( all_type ) ID ( formals ) block .

    }               reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    (               reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    ID              reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    INT             reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    STATIC          reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)


state 128

    (84) new_array -> new_array [ . ]

    ]               shift and go to state 160


state 129

    (78) expr -> unary_op expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    THIS            reduce using rule 78 (expr -> unary_op expr .)
    SUPER           reduce using rule 78 (expr -> unary_op expr .)
    (               reduce using rule 78 (expr -> unary_op expr .)
    NEW             reduce using rule 78 (expr -> unary_op expr .)
    INC             reduce using rule 78 (expr -> unary_op expr .)
    DEC             reduce using rule 78 (expr -> unary_op expr .)
    !               reduce using rule 78 (expr -> unary_op expr .)
    INT_CONST       reduce using rule 78 (expr -> unary_op expr .)
    FLOAT_CONST     reduce using rule 78 (expr -> unary_op expr .)
    STRING_CONST    reduce using rule 78 (expr -> unary_op expr .)
    NULL            reduce using rule 78 (expr -> unary_op expr .)
    TRUE            reduce using rule 78 (expr -> unary_op expr .)
    FALSE           reduce using rule 78 (expr -> unary_op expr .)
    ID              reduce using rule 78 (expr -> unary_op expr .)
    }               reduce using rule 78 (expr -> unary_op expr .)
    IF              reduce using rule 78 (expr -> unary_op expr .)
    WHILE           reduce using rule 78 (expr -> unary_op expr .)
    FOR             reduce using rule 78 (expr -> unary_op expr .)
    RETURN          reduce using rule 78 (expr -> unary_op expr .)
    BREAK           reduce using rule 78 (expr -> unary_op expr .)
    CONTINUE        reduce using rule 78 (expr -> unary_op expr .)
    {               reduce using rule 78 (expr -> unary_op expr .)
    INT             reduce using rule 78 (expr -> unary_op expr .)
    FLOAT           reduce using rule 78 (expr -> unary_op expr .)
    BOOLEAN         reduce using rule 78 (expr -> unary_op expr .)
    ELSE            reduce using rule 78 (expr -> unary_op expr .)
    )               reduce using rule 78 (expr -> unary_op expr .)
    ]               reduce using rule 78 (expr -> unary_op expr .)
    ,               reduce using rule 78 (expr -> unary_op expr .)
    ;               reduce using rule 78 (expr -> unary_op expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! -               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! *               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! /               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! AND             [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! OR              [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! EQL             [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! UNEQL           [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! <               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! >               [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! LE              [ reduce using rule 78 (expr -> unary_op expr .) ]
  ! GE              [ reduce using rule 78 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 130

    (87) new_array_temp -> NEW type . [ expr ]

    [               shift and go to state 161


state 131

    (60) primary -> NEW ID . ( have_arguments )
    (21) type -> ID .

    (               shift and go to state 151
    [               reduce using rule 21 (type -> ID .)


state 132

    (86) new_array_temp -> new_array_temp [ . expr ]
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 162
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 133

    (76) expr -> expr arith_op . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 163
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 134

    (92) bool_op -> AND .

    THIS            reduce using rule 92 (bool_op -> AND .)
    SUPER           reduce using rule 92 (bool_op -> AND .)
    (               reduce using rule 92 (bool_op -> AND .)
    NEW             reduce using rule 92 (bool_op -> AND .)
    INC             reduce using rule 92 (bool_op -> AND .)
    DEC             reduce using rule 92 (bool_op -> AND .)
    +               reduce using rule 92 (bool_op -> AND .)
    -               reduce using rule 92 (bool_op -> AND .)
    !               reduce using rule 92 (bool_op -> AND .)
    INT_CONST       reduce using rule 92 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 92 (bool_op -> AND .)
    STRING_CONST    reduce using rule 92 (bool_op -> AND .)
    NULL            reduce using rule 92 (bool_op -> AND .)
    TRUE            reduce using rule 92 (bool_op -> AND .)
    FALSE           reduce using rule 92 (bool_op -> AND .)
    ID              reduce using rule 92 (bool_op -> AND .)


state 135

    (98) bool_op -> LE .

    THIS            reduce using rule 98 (bool_op -> LE .)
    SUPER           reduce using rule 98 (bool_op -> LE .)
    (               reduce using rule 98 (bool_op -> LE .)
    NEW             reduce using rule 98 (bool_op -> LE .)
    INC             reduce using rule 98 (bool_op -> LE .)
    DEC             reduce using rule 98 (bool_op -> LE .)
    +               reduce using rule 98 (bool_op -> LE .)
    -               reduce using rule 98 (bool_op -> LE .)
    !               reduce using rule 98 (bool_op -> LE .)
    INT_CONST       reduce using rule 98 (bool_op -> LE .)
    FLOAT_CONST     reduce using rule 98 (bool_op -> LE .)
    STRING_CONST    reduce using rule 98 (bool_op -> LE .)
    NULL            reduce using rule 98 (bool_op -> LE .)
    TRUE            reduce using rule 98 (bool_op -> LE .)
    FALSE           reduce using rule 98 (bool_op -> LE .)
    ID              reduce using rule 98 (bool_op -> LE .)


state 136

    (88) arith_op -> + .

    THIS            reduce using rule 88 (arith_op -> + .)
    SUPER           reduce using rule 88 (arith_op -> + .)
    (               reduce using rule 88 (arith_op -> + .)
    NEW             reduce using rule 88 (arith_op -> + .)
    INC             reduce using rule 88 (arith_op -> + .)
    DEC             reduce using rule 88 (arith_op -> + .)
    +               reduce using rule 88 (arith_op -> + .)
    -               reduce using rule 88 (arith_op -> + .)
    !               reduce using rule 88 (arith_op -> + .)
    INT_CONST       reduce using rule 88 (arith_op -> + .)
    FLOAT_CONST     reduce using rule 88 (arith_op -> + .)
    STRING_CONST    reduce using rule 88 (arith_op -> + .)
    NULL            reduce using rule 88 (arith_op -> + .)
    TRUE            reduce using rule 88 (arith_op -> + .)
    FALSE           reduce using rule 88 (arith_op -> + .)
    ID              reduce using rule 88 (arith_op -> + .)


state 137

    (90) arith_op -> * .

    THIS            reduce using rule 90 (arith_op -> * .)
    SUPER           reduce using rule 90 (arith_op -> * .)
    (               reduce using rule 90 (arith_op -> * .)
    NEW             reduce using rule 90 (arith_op -> * .)
    INC             reduce using rule 90 (arith_op -> * .)
    DEC             reduce using rule 90 (arith_op -> * .)
    +               reduce using rule 90 (arith_op -> * .)
    -               reduce using rule 90 (arith_op -> * .)
    !               reduce using rule 90 (arith_op -> * .)
    INT_CONST       reduce using rule 90 (arith_op -> * .)
    FLOAT_CONST     reduce using rule 90 (arith_op -> * .)
    STRING_CONST    reduce using rule 90 (arith_op -> * .)
    NULL            reduce using rule 90 (arith_op -> * .)
    TRUE            reduce using rule 90 (arith_op -> * .)
    FALSE           reduce using rule 90 (arith_op -> * .)
    ID              reduce using rule 90 (arith_op -> * .)


state 138

    (89) arith_op -> - .

    THIS            reduce using rule 89 (arith_op -> - .)
    SUPER           reduce using rule 89 (arith_op -> - .)
    (               reduce using rule 89 (arith_op -> - .)
    NEW             reduce using rule 89 (arith_op -> - .)
    INC             reduce using rule 89 (arith_op -> - .)
    DEC             reduce using rule 89 (arith_op -> - .)
    +               reduce using rule 89 (arith_op -> - .)
    -               reduce using rule 89 (arith_op -> - .)
    !               reduce using rule 89 (arith_op -> - .)
    INT_CONST       reduce using rule 89 (arith_op -> - .)
    FLOAT_CONST     reduce using rule 89 (arith_op -> - .)
    STRING_CONST    reduce using rule 89 (arith_op -> - .)
    NULL            reduce using rule 89 (arith_op -> - .)
    TRUE            reduce using rule 89 (arith_op -> - .)
    FALSE           reduce using rule 89 (arith_op -> - .)
    ID              reduce using rule 89 (arith_op -> - .)


state 139

    (91) arith_op -> / .

    THIS            reduce using rule 91 (arith_op -> / .)
    SUPER           reduce using rule 91 (arith_op -> / .)
    (               reduce using rule 91 (arith_op -> / .)
    NEW             reduce using rule 91 (arith_op -> / .)
    INC             reduce using rule 91 (arith_op -> / .)
    DEC             reduce using rule 91 (arith_op -> / .)
    +               reduce using rule 91 (arith_op -> / .)
    -               reduce using rule 91 (arith_op -> / .)
    !               reduce using rule 91 (arith_op -> / .)
    INT_CONST       reduce using rule 91 (arith_op -> / .)
    FLOAT_CONST     reduce using rule 91 (arith_op -> / .)
    STRING_CONST    reduce using rule 91 (arith_op -> / .)
    NULL            reduce using rule 91 (arith_op -> / .)
    TRUE            reduce using rule 91 (arith_op -> / .)
    FALSE           reduce using rule 91 (arith_op -> / .)
    ID              reduce using rule 91 (arith_op -> / .)


state 140

    (96) bool_op -> < .

    THIS            reduce using rule 96 (bool_op -> < .)
    SUPER           reduce using rule 96 (bool_op -> < .)
    (               reduce using rule 96 (bool_op -> < .)
    NEW             reduce using rule 96 (bool_op -> < .)
    INC             reduce using rule 96 (bool_op -> < .)
    DEC             reduce using rule 96 (bool_op -> < .)
    +               reduce using rule 96 (bool_op -> < .)
    -               reduce using rule 96 (bool_op -> < .)
    !               reduce using rule 96 (bool_op -> < .)
    INT_CONST       reduce using rule 96 (bool_op -> < .)
    FLOAT_CONST     reduce using rule 96 (bool_op -> < .)
    STRING_CONST    reduce using rule 96 (bool_op -> < .)
    NULL            reduce using rule 96 (bool_op -> < .)
    TRUE            reduce using rule 96 (bool_op -> < .)
    FALSE           reduce using rule 96 (bool_op -> < .)
    ID              reduce using rule 96 (bool_op -> < .)


state 141

    (95) bool_op -> UNEQL .

    THIS            reduce using rule 95 (bool_op -> UNEQL .)
    SUPER           reduce using rule 95 (bool_op -> UNEQL .)
    (               reduce using rule 95 (bool_op -> UNEQL .)
    NEW             reduce using rule 95 (bool_op -> UNEQL .)
    INC             reduce using rule 95 (bool_op -> UNEQL .)
    DEC             reduce using rule 95 (bool_op -> UNEQL .)
    +               reduce using rule 95 (bool_op -> UNEQL .)
    -               reduce using rule 95 (bool_op -> UNEQL .)
    !               reduce using rule 95 (bool_op -> UNEQL .)
    INT_CONST       reduce using rule 95 (bool_op -> UNEQL .)
    FLOAT_CONST     reduce using rule 95 (bool_op -> UNEQL .)
    STRING_CONST    reduce using rule 95 (bool_op -> UNEQL .)
    NULL            reduce using rule 95 (bool_op -> UNEQL .)
    TRUE            reduce using rule 95 (bool_op -> UNEQL .)
    FALSE           reduce using rule 95 (bool_op -> UNEQL .)
    ID              reduce using rule 95 (bool_op -> UNEQL .)


state 142

    (77) expr -> expr bool_op . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 164
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 143

    (99) bool_op -> GE .

    THIS            reduce using rule 99 (bool_op -> GE .)
    SUPER           reduce using rule 99 (bool_op -> GE .)
    (               reduce using rule 99 (bool_op -> GE .)
    NEW             reduce using rule 99 (bool_op -> GE .)
    INC             reduce using rule 99 (bool_op -> GE .)
    DEC             reduce using rule 99 (bool_op -> GE .)
    +               reduce using rule 99 (bool_op -> GE .)
    -               reduce using rule 99 (bool_op -> GE .)
    !               reduce using rule 99 (bool_op -> GE .)
    INT_CONST       reduce using rule 99 (bool_op -> GE .)
    FLOAT_CONST     reduce using rule 99 (bool_op -> GE .)
    STRING_CONST    reduce using rule 99 (bool_op -> GE .)
    NULL            reduce using rule 99 (bool_op -> GE .)
    TRUE            reduce using rule 99 (bool_op -> GE .)
    FALSE           reduce using rule 99 (bool_op -> GE .)
    ID              reduce using rule 99 (bool_op -> GE .)


state 144

    (94) bool_op -> EQL .

    THIS            reduce using rule 94 (bool_op -> EQL .)
    SUPER           reduce using rule 94 (bool_op -> EQL .)
    (               reduce using rule 94 (bool_op -> EQL .)
    NEW             reduce using rule 94 (bool_op -> EQL .)
    INC             reduce using rule 94 (bool_op -> EQL .)
    DEC             reduce using rule 94 (bool_op -> EQL .)
    +               reduce using rule 94 (bool_op -> EQL .)
    -               reduce using rule 94 (bool_op -> EQL .)
    !               reduce using rule 94 (bool_op -> EQL .)
    INT_CONST       reduce using rule 94 (bool_op -> EQL .)
    FLOAT_CONST     reduce using rule 94 (bool_op -> EQL .)
    STRING_CONST    reduce using rule 94 (bool_op -> EQL .)
    NULL            reduce using rule 94 (bool_op -> EQL .)
    TRUE            reduce using rule 94 (bool_op -> EQL .)
    FALSE           reduce using rule 94 (bool_op -> EQL .)
    ID              reduce using rule 94 (bool_op -> EQL .)


state 145

    (93) bool_op -> OR .

    THIS            reduce using rule 93 (bool_op -> OR .)
    SUPER           reduce using rule 93 (bool_op -> OR .)
    (               reduce using rule 93 (bool_op -> OR .)
    NEW             reduce using rule 93 (bool_op -> OR .)
    INC             reduce using rule 93 (bool_op -> OR .)
    DEC             reduce using rule 93 (bool_op -> OR .)
    +               reduce using rule 93 (bool_op -> OR .)
    -               reduce using rule 93 (bool_op -> OR .)
    !               reduce using rule 93 (bool_op -> OR .)
    INT_CONST       reduce using rule 93 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 93 (bool_op -> OR .)
    STRING_CONST    reduce using rule 93 (bool_op -> OR .)
    NULL            reduce using rule 93 (bool_op -> OR .)
    TRUE            reduce using rule 93 (bool_op -> OR .)
    FALSE           reduce using rule 93 (bool_op -> OR .)
    ID              reduce using rule 93 (bool_op -> OR .)


state 146

    (97) bool_op -> > .

    THIS            reduce using rule 97 (bool_op -> > .)
    SUPER           reduce using rule 97 (bool_op -> > .)
    (               reduce using rule 97 (bool_op -> > .)
    NEW             reduce using rule 97 (bool_op -> > .)
    INC             reduce using rule 97 (bool_op -> > .)
    DEC             reduce using rule 97 (bool_op -> > .)
    +               reduce using rule 97 (bool_op -> > .)
    -               reduce using rule 97 (bool_op -> > .)
    !               reduce using rule 97 (bool_op -> > .)
    INT_CONST       reduce using rule 97 (bool_op -> > .)
    FLOAT_CONST     reduce using rule 97 (bool_op -> > .)
    STRING_CONST    reduce using rule 97 (bool_op -> > .)
    NULL            reduce using rule 97 (bool_op -> > .)
    TRUE            reduce using rule 97 (bool_op -> > .)
    FALSE           reduce using rule 97 (bool_op -> > .)
    ID              reduce using rule 97 (bool_op -> > .)


state 147

    (48) exprs -> exprs expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
    THIS            reduce using rule 48 (exprs -> exprs expr .)
    SUPER           reduce using rule 48 (exprs -> exprs expr .)
    (               reduce using rule 48 (exprs -> exprs expr .)
    NEW             reduce using rule 48 (exprs -> exprs expr .)
    INC             reduce using rule 48 (exprs -> exprs expr .)
    DEC             reduce using rule 48 (exprs -> exprs expr .)
    !               reduce using rule 48 (exprs -> exprs expr .)
    INT_CONST       reduce using rule 48 (exprs -> exprs expr .)
    FLOAT_CONST     reduce using rule 48 (exprs -> exprs expr .)
    STRING_CONST    reduce using rule 48 (exprs -> exprs expr .)
    NULL            reduce using rule 48 (exprs -> exprs expr .)
    TRUE            reduce using rule 48 (exprs -> exprs expr .)
    FALSE           reduce using rule 48 (exprs -> exprs expr .)
    ID              reduce using rule 48 (exprs -> exprs expr .)
    }               reduce using rule 48 (exprs -> exprs expr .)
    IF              reduce using rule 48 (exprs -> exprs expr .)
    WHILE           reduce using rule 48 (exprs -> exprs expr .)
    FOR             reduce using rule 48 (exprs -> exprs expr .)
    RETURN          reduce using rule 48 (exprs -> exprs expr .)
    BREAK           reduce using rule 48 (exprs -> exprs expr .)
    CONTINUE        reduce using rule 48 (exprs -> exprs expr .)
    {               reduce using rule 48 (exprs -> exprs expr .)
    INT             reduce using rule 48 (exprs -> exprs expr .)
    FLOAT           reduce using rule 48 (exprs -> exprs expr .)
    BOOLEAN         reduce using rule 48 (exprs -> exprs expr .)
    ELSE            reduce using rule 48 (exprs -> exprs expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 48 (exprs -> exprs expr .) ]
  ! -               [ reduce using rule 48 (exprs -> exprs expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 148

    (69) field_access -> primary . ID .

    (               reduce using rule 69 (field_access -> primary . ID .)
    =               reduce using rule 69 (field_access -> primary . ID .)
    INC             reduce using rule 69 (field_access -> primary . ID .)
    DEC             reduce using rule 69 (field_access -> primary . ID .)
    .               reduce using rule 69 (field_access -> primary . ID .)
    [               reduce using rule 69 (field_access -> primary . ID .)
    )               reduce using rule 69 (field_access -> primary . ID .)
    +               reduce using rule 69 (field_access -> primary . ID .)
    -               reduce using rule 69 (field_access -> primary . ID .)
    *               reduce using rule 69 (field_access -> primary . ID .)
    /               reduce using rule 69 (field_access -> primary . ID .)
    AND             reduce using rule 69 (field_access -> primary . ID .)
    OR              reduce using rule 69 (field_access -> primary . ID .)
    EQL             reduce using rule 69 (field_access -> primary . ID .)
    UNEQL           reduce using rule 69 (field_access -> primary . ID .)
    <               reduce using rule 69 (field_access -> primary . ID .)
    >               reduce using rule 69 (field_access -> primary . ID .)
    LE              reduce using rule 69 (field_access -> primary . ID .)
    GE              reduce using rule 69 (field_access -> primary . ID .)
    THIS            reduce using rule 69 (field_access -> primary . ID .)
    SUPER           reduce using rule 69 (field_access -> primary . ID .)
    NEW             reduce using rule 69 (field_access -> primary . ID .)
    !               reduce using rule 69 (field_access -> primary . ID .)
    INT_CONST       reduce using rule 69 (field_access -> primary . ID .)
    FLOAT_CONST     reduce using rule 69 (field_access -> primary . ID .)
    STRING_CONST    reduce using rule 69 (field_access -> primary . ID .)
    NULL            reduce using rule 69 (field_access -> primary . ID .)
    TRUE            reduce using rule 69 (field_access -> primary . ID .)
    FALSE           reduce using rule 69 (field_access -> primary . ID .)
    ID              reduce using rule 69 (field_access -> primary . ID .)
    }               reduce using rule 69 (field_access -> primary . ID .)
    IF              reduce using rule 69 (field_access -> primary . ID .)
    WHILE           reduce using rule 69 (field_access -> primary . ID .)
    FOR             reduce using rule 69 (field_access -> primary . ID .)
    RETURN          reduce using rule 69 (field_access -> primary . ID .)
    BREAK           reduce using rule 69 (field_access -> primary . ID .)
    CONTINUE        reduce using rule 69 (field_access -> primary . ID .)
    {               reduce using rule 69 (field_access -> primary . ID .)
    INT             reduce using rule 69 (field_access -> primary . ID .)
    FLOAT           reduce using rule 69 (field_access -> primary . ID .)
    BOOLEAN         reduce using rule 69 (field_access -> primary . ID .)
    ELSE            reduce using rule 69 (field_access -> primary . ID .)
    ]               reduce using rule 69 (field_access -> primary . ID .)
    ,               reduce using rule 69 (field_access -> primary . ID .)
    ;               reduce using rule 69 (field_access -> primary . ID .)


state 149

    (71) array_access -> primary [ expr . ]
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ]               shift and go to state 165
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 150

    (40) stmt -> WHILE ( expr . ) stmt
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    )               shift and go to state 166
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 151

    (60) primary -> NEW ID ( . have_arguments )
    (63) have_arguments -> . arguments
    (64) have_arguments -> . empty
    (65) arguments -> . arguments , expr
    (66) arguments -> . expr
    (105) empty -> .
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    )               reduce using rule 105 (empty -> .)
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    have_arguments                 shift and go to state 167
    field_access                   shift and go to state 107
    expr                           shift and go to state 156
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    arguments                      shift and go to state 153
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113
    empty                          shift and go to state 154
    unary_op                       shift and go to state 101

state 152

    (59) primary -> ( expr ) .

    .               reduce using rule 59 (primary -> ( expr ) .)
    [               reduce using rule 59 (primary -> ( expr ) .)
    )               reduce using rule 59 (primary -> ( expr ) .)
    +               reduce using rule 59 (primary -> ( expr ) .)
    -               reduce using rule 59 (primary -> ( expr ) .)
    *               reduce using rule 59 (primary -> ( expr ) .)
    /               reduce using rule 59 (primary -> ( expr ) .)
    AND             reduce using rule 59 (primary -> ( expr ) .)
    OR              reduce using rule 59 (primary -> ( expr ) .)
    EQL             reduce using rule 59 (primary -> ( expr ) .)
    UNEQL           reduce using rule 59 (primary -> ( expr ) .)
    <               reduce using rule 59 (primary -> ( expr ) .)
    >               reduce using rule 59 (primary -> ( expr ) .)
    LE              reduce using rule 59 (primary -> ( expr ) .)
    GE              reduce using rule 59 (primary -> ( expr ) .)
    ]               reduce using rule 59 (primary -> ( expr ) .)
    THIS            reduce using rule 59 (primary -> ( expr ) .)
    SUPER           reduce using rule 59 (primary -> ( expr ) .)
    (               reduce using rule 59 (primary -> ( expr ) .)
    NEW             reduce using rule 59 (primary -> ( expr ) .)
    INC             reduce using rule 59 (primary -> ( expr ) .)
    DEC             reduce using rule 59 (primary -> ( expr ) .)
    !               reduce using rule 59 (primary -> ( expr ) .)
    INT_CONST       reduce using rule 59 (primary -> ( expr ) .)
    FLOAT_CONST     reduce using rule 59 (primary -> ( expr ) .)
    STRING_CONST    reduce using rule 59 (primary -> ( expr ) .)
    NULL            reduce using rule 59 (primary -> ( expr ) .)
    TRUE            reduce using rule 59 (primary -> ( expr ) .)
    FALSE           reduce using rule 59 (primary -> ( expr ) .)
    ID              reduce using rule 59 (primary -> ( expr ) .)
    }               reduce using rule 59 (primary -> ( expr ) .)
    IF              reduce using rule 59 (primary -> ( expr ) .)
    WHILE           reduce using rule 59 (primary -> ( expr ) .)
    FOR             reduce using rule 59 (primary -> ( expr ) .)
    RETURN          reduce using rule 59 (primary -> ( expr ) .)
    BREAK           reduce using rule 59 (primary -> ( expr ) .)
    CONTINUE        reduce using rule 59 (primary -> ( expr ) .)
    {               reduce using rule 59 (primary -> ( expr ) .)
    INT             reduce using rule 59 (primary -> ( expr ) .)
    FLOAT           reduce using rule 59 (primary -> ( expr ) .)
    BOOLEAN         reduce using rule 59 (primary -> ( expr ) .)
    ELSE            reduce using rule 59 (primary -> ( expr ) .)
    ,               reduce using rule 59 (primary -> ( expr ) .)
    ;               reduce using rule 59 (primary -> ( expr ) .)


state 153

    (63) have_arguments -> arguments .
    (65) arguments -> arguments . , expr

    )               reduce using rule 63 (have_arguments -> arguments .)
    ,               shift and go to state 168


state 154

    (64) have_arguments -> empty .

    )               reduce using rule 64 (have_arguments -> empty .)


state 155

    (72) method_invocation -> field_access ( have_arguments . )

    )               shift and go to state 169


state 156

    (66) arguments -> expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ,               reduce using rule 66 (arguments -> expr .)
    )               reduce using rule 66 (arguments -> expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 157

    (41) stmt -> FOR ( stmt_expr . ; expr ; stmt_expr ) stmt

    ;               shift and go to state 170


state 158

    (38) stmt -> IF ( expr . ) stmt
    (39) stmt -> IF ( expr . ) stmt ELSE stmt
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    )               shift and go to state 171
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 159

    (79) assign -> lhs = expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    THIS            reduce using rule 79 (assign -> lhs = expr .)
    SUPER           reduce using rule 79 (assign -> lhs = expr .)
    (               reduce using rule 79 (assign -> lhs = expr .)
    NEW             reduce using rule 79 (assign -> lhs = expr .)
    INC             reduce using rule 79 (assign -> lhs = expr .)
    DEC             reduce using rule 79 (assign -> lhs = expr .)
    !               reduce using rule 79 (assign -> lhs = expr .)
    INT_CONST       reduce using rule 79 (assign -> lhs = expr .)
    FLOAT_CONST     reduce using rule 79 (assign -> lhs = expr .)
    STRING_CONST    reduce using rule 79 (assign -> lhs = expr .)
    NULL            reduce using rule 79 (assign -> lhs = expr .)
    TRUE            reduce using rule 79 (assign -> lhs = expr .)
    FALSE           reduce using rule 79 (assign -> lhs = expr .)
    ID              reduce using rule 79 (assign -> lhs = expr .)
    }               reduce using rule 79 (assign -> lhs = expr .)
    IF              reduce using rule 79 (assign -> lhs = expr .)
    WHILE           reduce using rule 79 (assign -> lhs = expr .)
    FOR             reduce using rule 79 (assign -> lhs = expr .)
    RETURN          reduce using rule 79 (assign -> lhs = expr .)
    BREAK           reduce using rule 79 (assign -> lhs = expr .)
    CONTINUE        reduce using rule 79 (assign -> lhs = expr .)
    {               reduce using rule 79 (assign -> lhs = expr .)
    INT             reduce using rule 79 (assign -> lhs = expr .)
    FLOAT           reduce using rule 79 (assign -> lhs = expr .)
    BOOLEAN         reduce using rule 79 (assign -> lhs = expr .)
    ELSE            reduce using rule 79 (assign -> lhs = expr .)
    )               reduce using rule 79 (assign -> lhs = expr .)
    ,               reduce using rule 79 (assign -> lhs = expr .)
    ]               reduce using rule 79 (assign -> lhs = expr .)
    ;               reduce using rule 79 (assign -> lhs = expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! -               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! *               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! /               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! AND             [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! OR              [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! EQL             [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! UNEQL           [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! <               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! >               [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! LE              [ reduce using rule 79 (assign -> lhs = expr .) ]
  ! GE              [ reduce using rule 79 (assign -> lhs = expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 160

    (84) new_array -> new_array [ ] .

    [               reduce using rule 84 (new_array -> new_array [ ] .)
    ]               reduce using rule 84 (new_array -> new_array [ ] .)
    +               reduce using rule 84 (new_array -> new_array [ ] .)
    -               reduce using rule 84 (new_array -> new_array [ ] .)
    *               reduce using rule 84 (new_array -> new_array [ ] .)
    /               reduce using rule 84 (new_array -> new_array [ ] .)
    AND             reduce using rule 84 (new_array -> new_array [ ] .)
    OR              reduce using rule 84 (new_array -> new_array [ ] .)
    EQL             reduce using rule 84 (new_array -> new_array [ ] .)
    UNEQL           reduce using rule 84 (new_array -> new_array [ ] .)
    <               reduce using rule 84 (new_array -> new_array [ ] .)
    >               reduce using rule 84 (new_array -> new_array [ ] .)
    LE              reduce using rule 84 (new_array -> new_array [ ] .)
    GE              reduce using rule 84 (new_array -> new_array [ ] .)
    )               reduce using rule 84 (new_array -> new_array [ ] .)
    ;               reduce using rule 84 (new_array -> new_array [ ] .)
    ,               reduce using rule 84 (new_array -> new_array [ ] .)
    THIS            reduce using rule 84 (new_array -> new_array [ ] .)
    SUPER           reduce using rule 84 (new_array -> new_array [ ] .)
    (               reduce using rule 84 (new_array -> new_array [ ] .)
    NEW             reduce using rule 84 (new_array -> new_array [ ] .)
    INC             reduce using rule 84 (new_array -> new_array [ ] .)
    DEC             reduce using rule 84 (new_array -> new_array [ ] .)
    !               reduce using rule 84 (new_array -> new_array [ ] .)
    INT_CONST       reduce using rule 84 (new_array -> new_array [ ] .)
    FLOAT_CONST     reduce using rule 84 (new_array -> new_array [ ] .)
    STRING_CONST    reduce using rule 84 (new_array -> new_array [ ] .)
    NULL            reduce using rule 84 (new_array -> new_array [ ] .)
    TRUE            reduce using rule 84 (new_array -> new_array [ ] .)
    FALSE           reduce using rule 84 (new_array -> new_array [ ] .)
    ID              reduce using rule 84 (new_array -> new_array [ ] .)
    }               reduce using rule 84 (new_array -> new_array [ ] .)
    IF              reduce using rule 84 (new_array -> new_array [ ] .)
    WHILE           reduce using rule 84 (new_array -> new_array [ ] .)
    FOR             reduce using rule 84 (new_array -> new_array [ ] .)
    RETURN          reduce using rule 84 (new_array -> new_array [ ] .)
    BREAK           reduce using rule 84 (new_array -> new_array [ ] .)
    CONTINUE        reduce using rule 84 (new_array -> new_array [ ] .)
    {               reduce using rule 84 (new_array -> new_array [ ] .)
    INT             reduce using rule 84 (new_array -> new_array [ ] .)
    FLOAT           reduce using rule 84 (new_array -> new_array [ ] .)
    BOOLEAN         reduce using rule 84 (new_array -> new_array [ ] .)
    ELSE            reduce using rule 84 (new_array -> new_array [ ] .)


state 161

    (87) new_array_temp -> NEW type [ . expr ]
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 172
    primary                        shift and go to state 100
    array_access                   shift and go to state 72
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    assign                         shift and go to state 113

state 162

    (86) new_array_temp -> new_array_temp [ expr . ]
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ]               shift and go to state 173
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 163

    (76) expr -> expr arith_op expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    THIS            reduce using rule 76 (expr -> expr arith_op expr .)
    SUPER           reduce using rule 76 (expr -> expr arith_op expr .)
    (               reduce using rule 76 (expr -> expr arith_op expr .)
    NEW             reduce using rule 76 (expr -> expr arith_op expr .)
    INC             reduce using rule 76 (expr -> expr arith_op expr .)
    DEC             reduce using rule 76 (expr -> expr arith_op expr .)
    !               reduce using rule 76 (expr -> expr arith_op expr .)
    INT_CONST       reduce using rule 76 (expr -> expr arith_op expr .)
    FLOAT_CONST     reduce using rule 76 (expr -> expr arith_op expr .)
    STRING_CONST    reduce using rule 76 (expr -> expr arith_op expr .)
    NULL            reduce using rule 76 (expr -> expr arith_op expr .)
    TRUE            reduce using rule 76 (expr -> expr arith_op expr .)
    FALSE           reduce using rule 76 (expr -> expr arith_op expr .)
    ID              reduce using rule 76 (expr -> expr arith_op expr .)
    }               reduce using rule 76 (expr -> expr arith_op expr .)
    IF              reduce using rule 76 (expr -> expr arith_op expr .)
    WHILE           reduce using rule 76 (expr -> expr arith_op expr .)
    FOR             reduce using rule 76 (expr -> expr arith_op expr .)
    RETURN          reduce using rule 76 (expr -> expr arith_op expr .)
    BREAK           reduce using rule 76 (expr -> expr arith_op expr .)
    CONTINUE        reduce using rule 76 (expr -> expr arith_op expr .)
    {               reduce using rule 76 (expr -> expr arith_op expr .)
    INT             reduce using rule 76 (expr -> expr arith_op expr .)
    FLOAT           reduce using rule 76 (expr -> expr arith_op expr .)
    BOOLEAN         reduce using rule 76 (expr -> expr arith_op expr .)
    ELSE            reduce using rule 76 (expr -> expr arith_op expr .)
    )               reduce using rule 76 (expr -> expr arith_op expr .)
    ]               reduce using rule 76 (expr -> expr arith_op expr .)
    ,               reduce using rule 76 (expr -> expr arith_op expr .)
    ;               reduce using rule 76 (expr -> expr arith_op expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! -               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! *               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! /               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! EQL             [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! UNEQL           [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! <               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! >               [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! LE              [ reduce using rule 76 (expr -> expr arith_op expr .) ]
  ! GE              [ reduce using rule 76 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 164

    (77) expr -> expr bool_op expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    THIS            reduce using rule 77 (expr -> expr bool_op expr .)
    SUPER           reduce using rule 77 (expr -> expr bool_op expr .)
    (               reduce using rule 77 (expr -> expr bool_op expr .)
    NEW             reduce using rule 77 (expr -> expr bool_op expr .)
    INC             reduce using rule 77 (expr -> expr bool_op expr .)
    DEC             reduce using rule 77 (expr -> expr bool_op expr .)
    !               reduce using rule 77 (expr -> expr bool_op expr .)
    INT_CONST       reduce using rule 77 (expr -> expr bool_op expr .)
    FLOAT_CONST     reduce using rule 77 (expr -> expr bool_op expr .)
    STRING_CONST    reduce using rule 77 (expr -> expr bool_op expr .)
    NULL            reduce using rule 77 (expr -> expr bool_op expr .)
    TRUE            reduce using rule 77 (expr -> expr bool_op expr .)
    FALSE           reduce using rule 77 (expr -> expr bool_op expr .)
    ID              reduce using rule 77 (expr -> expr bool_op expr .)
    }               reduce using rule 77 (expr -> expr bool_op expr .)
    IF              reduce using rule 77 (expr -> expr bool_op expr .)
    WHILE           reduce using rule 77 (expr -> expr bool_op expr .)
    FOR             reduce using rule 77 (expr -> expr bool_op expr .)
    RETURN          reduce using rule 77 (expr -> expr bool_op expr .)
    BREAK           reduce using rule 77 (expr -> expr bool_op expr .)
    CONTINUE        reduce using rule 77 (expr -> expr bool_op expr .)
    {               reduce using rule 77 (expr -> expr bool_op expr .)
    INT             reduce using rule 77 (expr -> expr bool_op expr .)
    FLOAT           reduce using rule 77 (expr -> expr bool_op expr .)
    BOOLEAN         reduce using rule 77 (expr -> expr bool_op expr .)
    ELSE            reduce using rule 77 (expr -> expr bool_op expr .)
    )               reduce using rule 77 (expr -> expr bool_op expr .)
    ]               reduce using rule 77 (expr -> expr bool_op expr .)
    ,               reduce using rule 77 (expr -> expr bool_op expr .)
    ;               reduce using rule 77 (expr -> expr bool_op expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

  ! +               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! -               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! *               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! /               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! EQL             [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! UNEQL           [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! <               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! >               [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! LE              [ reduce using rule 77 (expr -> expr bool_op expr .) ]
  ! GE              [ reduce using rule 77 (expr -> expr bool_op expr .) ]

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 165

    (71) array_access -> primary [ expr ] .

    =               reduce using rule 71 (array_access -> primary [ expr ] .)
    INC             reduce using rule 71 (array_access -> primary [ expr ] .)
    DEC             reduce using rule 71 (array_access -> primary [ expr ] .)
    .               reduce using rule 71 (array_access -> primary [ expr ] .)
    [               reduce using rule 71 (array_access -> primary [ expr ] .)
    +               reduce using rule 71 (array_access -> primary [ expr ] .)
    -               reduce using rule 71 (array_access -> primary [ expr ] .)
    *               reduce using rule 71 (array_access -> primary [ expr ] .)
    /               reduce using rule 71 (array_access -> primary [ expr ] .)
    AND             reduce using rule 71 (array_access -> primary [ expr ] .)
    OR              reduce using rule 71 (array_access -> primary [ expr ] .)
    EQL             reduce using rule 71 (array_access -> primary [ expr ] .)
    UNEQL           reduce using rule 71 (array_access -> primary [ expr ] .)
    <               reduce using rule 71 (array_access -> primary [ expr ] .)
    >               reduce using rule 71 (array_access -> primary [ expr ] .)
    LE              reduce using rule 71 (array_access -> primary [ expr ] .)
    GE              reduce using rule 71 (array_access -> primary [ expr ] .)
    ,               reduce using rule 71 (array_access -> primary [ expr ] .)
    )               reduce using rule 71 (array_access -> primary [ expr ] .)
    THIS            reduce using rule 71 (array_access -> primary [ expr ] .)
    SUPER           reduce using rule 71 (array_access -> primary [ expr ] .)
    (               reduce using rule 71 (array_access -> primary [ expr ] .)
    NEW             reduce using rule 71 (array_access -> primary [ expr ] .)
    !               reduce using rule 71 (array_access -> primary [ expr ] .)
    INT_CONST       reduce using rule 71 (array_access -> primary [ expr ] .)
    FLOAT_CONST     reduce using rule 71 (array_access -> primary [ expr ] .)
    STRING_CONST    reduce using rule 71 (array_access -> primary [ expr ] .)
    NULL            reduce using rule 71 (array_access -> primary [ expr ] .)
    TRUE            reduce using rule 71 (array_access -> primary [ expr ] .)
    FALSE           reduce using rule 71 (array_access -> primary [ expr ] .)
    ID              reduce using rule 71 (array_access -> primary [ expr ] .)
    }               reduce using rule 71 (array_access -> primary [ expr ] .)
    IF              reduce using rule 71 (array_access -> primary [ expr ] .)
    WHILE           reduce using rule 71 (array_access -> primary [ expr ] .)
    FOR             reduce using rule 71 (array_access -> primary [ expr ] .)
    RETURN          reduce using rule 71 (array_access -> primary [ expr ] .)
    BREAK           reduce using rule 71 (array_access -> primary [ expr ] .)
    CONTINUE        reduce using rule 71 (array_access -> primary [ expr ] .)
    {               reduce using rule 71 (array_access -> primary [ expr ] .)
    INT             reduce using rule 71 (array_access -> primary [ expr ] .)
    FLOAT           reduce using rule 71 (array_access -> primary [ expr ] .)
    BOOLEAN         reduce using rule 71 (array_access -> primary [ expr ] .)
    ELSE            reduce using rule 71 (array_access -> primary [ expr ] .)
    ]               reduce using rule 71 (array_access -> primary [ expr ] .)
    ;               reduce using rule 71 (array_access -> primary [ expr ] .)


state 166

    (40) stmt -> WHILE ( expr ) . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( stmt_expr ; expr ; stmt_expr ) stmt
    (42) stmt -> . RETURN exprs
    (43) stmt -> . stmt_expr
    (44) stmt -> . BREAK
    (45) stmt -> . CONTINUE
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    IF              shift and go to state 87
    WHILE           shift and go to state 68
    FOR             shift and go to state 81
    RETURN          shift and go to state 66
    BREAK           shift and go to state 90
    CONTINUE        shift and go to state 91
    {               shift and go to state 53
    INC             shift and go to state 96
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 85
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    stmt_expr                      shift and go to state 77
    primary                        shift and go to state 67
    var_decl                       shift and go to state 89
    literal                        shift and go to state 78
    array_access                   shift and go to state 72
    lhs                            shift and go to state 92
    stmt                           shift and go to state 174
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 167

    (60) primary -> NEW ID ( have_arguments . )

    )               shift and go to state 175


state 168

    (65) arguments -> arguments , . expr
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    field_access                   shift and go to state 107
    expr                           shift and go to state 176
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 106
    array_access                   shift and go to state 72
    assign                         shift and go to state 113
    unary_op                       shift and go to state 101

state 169

    (72) method_invocation -> field_access ( have_arguments ) .

    }               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    IF              reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    WHILE           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    FOR             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    RETURN          reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    BREAK           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    CONTINUE        reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    {               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    INC             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    DEC             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    INT             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    FLOAT           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    BOOLEAN         reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    ID              reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    THIS            reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    SUPER           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    (               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    NEW             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    INT_CONST       reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    FLOAT_CONST     reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    STRING_CONST    reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    NULL            reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    TRUE            reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    FALSE           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    ELSE            reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    .               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    [               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    +               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    -               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    *               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    /               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    AND             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    OR              reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    EQL             reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    UNEQL           reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    <               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    >               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    LE              reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    GE              reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    ,               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    )               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    !               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    ]               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)
    ;               reduce using rule 72 (method_invocation -> field_access ( have_arguments ) .)


state 170

    (41) stmt -> FOR ( stmt_expr ; . expr ; stmt_expr ) stmt
    (73) expr -> . primary
    (74) expr -> . assign
    (75) expr -> . new_array
    (76) expr -> . expr arith_op expr
    (77) expr -> . expr bool_op expr
    (78) expr -> . unary_op expr
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (84) new_array -> . new_array [ ]
    (85) new_array -> . new_array_temp
    (100) unary_op -> . +
    (101) unary_op -> . -
    (102) unary_op -> . !
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (72) method_invocation -> . field_access ( have_arguments )
    (86) new_array_temp -> . new_array_temp [ expr ]
    (87) new_array_temp -> . NEW type [ expr ]
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]

    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 102
    INC             shift and go to state 96
    DEC             shift and go to state 71
    +               shift and go to state 104
    -               shift and go to state 105
    !               shift and go to state 103
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88
    ID              shift and go to state 109

    new_array                      shift and go to state 99
    new_array_temp                 shift and go to state 108
    expr                           shift and go to state 177
    primary                        shift and go to state 100
    literal                        shift and go to state 78
    lhs                            shift and go to state 112
    unary_op                       shift and go to state 101
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 107
    array_access                   shift and go to state 72
    assign                         shift and go to state 113

state 171

    (38) stmt -> IF ( expr ) . stmt
    (39) stmt -> IF ( expr ) . stmt ELSE stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( stmt_expr ; expr ; stmt_expr ) stmt
    (42) stmt -> . RETURN exprs
    (43) stmt -> . stmt_expr
    (44) stmt -> . BREAK
    (45) stmt -> . CONTINUE
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    IF              shift and go to state 87
    WHILE           shift and go to state 68
    FOR             shift and go to state 81
    RETURN          shift and go to state 66
    BREAK           shift and go to state 90
    CONTINUE        shift and go to state 91
    {               shift and go to state 53
    INC             shift and go to state 96
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 85
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    stmt_expr                      shift and go to state 77
    primary                        shift and go to state 67
    var_decl                       shift and go to state 89
    literal                        shift and go to state 78
    array_access                   shift and go to state 72
    lhs                            shift and go to state 92
    stmt                           shift and go to state 178
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 172

    (87) new_array_temp -> NEW type [ expr . ]
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ]               shift and go to state 179
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 173

    (86) new_array_temp -> new_array_temp [ expr ] .

    [               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    +               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    -               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    *               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    /               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    AND             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    OR              reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    EQL             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    UNEQL           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    <               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    >               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    LE              reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    GE              reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    ,               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    )               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    ]               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    THIS            reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    SUPER           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    (               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    NEW             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    INC             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    DEC             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    !               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    INT_CONST       reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    FLOAT_CONST     reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    STRING_CONST    reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    NULL            reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    TRUE            reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    FALSE           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    ID              reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    }               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    IF              reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    WHILE           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    FOR             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    RETURN          reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    BREAK           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    CONTINUE        reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    {               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    INT             reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    FLOAT           reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    BOOLEAN         reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    ELSE            reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)
    ;               reduce using rule 86 (new_array_temp -> new_array_temp [ expr ] .)


state 174

    (40) stmt -> WHILE ( expr ) stmt .

    }               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INT_CONST       reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    NULL            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)


state 175

    (60) primary -> NEW ID ( have_arguments ) .

    .               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    [               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    )               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    +               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    -               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    *               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    /               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    AND             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    OR              reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    EQL             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    UNEQL           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    <               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    >               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    LE              reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    GE              reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    ]               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    THIS            reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    SUPER           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    (               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    NEW             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    INC             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    DEC             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    !               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    INT_CONST       reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    FLOAT_CONST     reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    STRING_CONST    reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    NULL            reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    TRUE            reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    FALSE           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    ID              reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    }               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    IF              reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    WHILE           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    FOR             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    RETURN          reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    BREAK           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    CONTINUE        reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    {               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    INT             reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    FLOAT           reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    BOOLEAN         reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    ELSE            reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    ,               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)
    ;               reduce using rule 60 (primary -> NEW ID ( have_arguments ) .)


state 176

    (65) arguments -> arguments , expr .
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ,               reduce using rule 65 (arguments -> arguments , expr .)
    )               reduce using rule 65 (arguments -> arguments , expr .)
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 177

    (41) stmt -> FOR ( stmt_expr ; expr . ; stmt_expr ) stmt
    (76) expr -> expr . arith_op expr
    (77) expr -> expr . bool_op expr
    (88) arith_op -> . +
    (89) arith_op -> . -
    (90) arith_op -> . *
    (91) arith_op -> . /
    (92) bool_op -> . AND
    (93) bool_op -> . OR
    (94) bool_op -> . EQL
    (95) bool_op -> . UNEQL
    (96) bool_op -> . <
    (97) bool_op -> . >
    (98) bool_op -> . LE
    (99) bool_op -> . GE

    ;               shift and go to state 180
    +               shift and go to state 136
    -               shift and go to state 138
    *               shift and go to state 137
    /               shift and go to state 139
    AND             shift and go to state 134
    OR              shift and go to state 145
    EQL             shift and go to state 144
    UNEQL           shift and go to state 141
    <               shift and go to state 140
    >               shift and go to state 146
    LE              shift and go to state 135
    GE              shift and go to state 143

    arith_op                       shift and go to state 133
    bool_op                        shift and go to state 142

state 178

    (38) stmt -> IF ( expr ) stmt .
    (39) stmt -> IF ( expr ) stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    }               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    BOOLEAN         reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    (               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INT_CONST       reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    STRING_CONST    reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    NULL            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 181

  ! ELSE            [ reduce using rule 38 (stmt -> IF ( expr ) stmt .) ]


state 179

    (87) new_array_temp -> NEW type [ expr ] .

    [               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    +               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    -               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    *               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    /               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    AND             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    OR              reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    EQL             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    UNEQL           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    <               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    >               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    LE              reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    GE              reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    ,               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    )               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    ]               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    THIS            reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    SUPER           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    (               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    NEW             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    INC             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    DEC             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    !               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    INT_CONST       reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    FLOAT_CONST     reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    STRING_CONST    reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    NULL            reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    TRUE            reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    FALSE           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    ID              reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    }               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    IF              reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    WHILE           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    FOR             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    RETURN          reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    BREAK           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    CONTINUE        reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    {               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    INT             reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    FLOAT           reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    BOOLEAN         reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    ELSE            reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)
    ;               reduce using rule 87 (new_array_temp -> NEW type [ expr ] .)


state 180

    (41) stmt -> FOR ( stmt_expr ; expr ; . stmt_expr ) stmt
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    INC             shift and go to state 96
    DEC             shift and go to state 71
    ID              shift and go to state 109
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    primary                        shift and go to state 67
    stmt_expr                      shift and go to state 182
    literal                        shift and go to state 78
    lhs                            shift and go to state 92
    method_invocation              shift and go to state 79
    array_access                   shift and go to state 72
    assign                         shift and go to state 94

state 181

    (39) stmt -> IF ( expr ) stmt ELSE . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( stmt_expr ; expr ; stmt_expr ) stmt
    (42) stmt -> . RETURN exprs
    (43) stmt -> . stmt_expr
    (44) stmt -> . BREAK
    (45) stmt -> . CONTINUE
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    IF              shift and go to state 87
    WHILE           shift and go to state 68
    FOR             shift and go to state 81
    RETURN          shift and go to state 66
    BREAK           shift and go to state 90
    CONTINUE        shift and go to state 91
    {               shift and go to state 53
    INC             shift and go to state 96
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 85
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    stmt_expr                      shift and go to state 77
    primary                        shift and go to state 67
    var_decl                       shift and go to state 89
    literal                        shift and go to state 78
    array_access                   shift and go to state 72
    lhs                            shift and go to state 92
    stmt                           shift and go to state 183
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 182

    (41) stmt -> FOR ( stmt_expr ; expr ; stmt_expr . ) stmt

    )               shift and go to state 184


state 183

    (39) stmt -> IF ( expr ) stmt ELSE stmt .

    }               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_CONST       reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_CONST    reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NULL            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)


state 184

    (41) stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( stmt_expr ; expr ; stmt_expr ) stmt
    (42) stmt -> . RETURN exprs
    (43) stmt -> . stmt_expr
    (44) stmt -> . BREAK
    (45) stmt -> . CONTINUE
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (79) assign -> . lhs = expr
    (80) assign -> . lhs INC
    (81) assign -> . INC lhs
    (82) assign -> . lhs DEC
    (83) assign -> . DEC lhs
    (72) method_invocation -> . field_access ( have_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) lhs -> . field_access
    (68) lhs -> . array_access
    (69) field_access -> . primary . ID
    (70) field_access -> . ID
    (71) array_access -> . primary [ expr ]
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . ( expr )
    (60) primary -> . NEW ID ( have_arguments )
    (61) primary -> . lhs
    (62) primary -> . method_invocation
    (50) literal -> . INT_CONST
    (51) literal -> . FLOAT_CONST
    (52) literal -> . STRING_CONST
    (53) literal -> . NULL
    (54) literal -> . TRUE
    (55) literal -> . FALSE

    IF              shift and go to state 87
    WHILE           shift and go to state 68
    FOR             shift and go to state 81
    RETURN          shift and go to state 66
    BREAK           shift and go to state 90
    CONTINUE        shift and go to state 91
    {               shift and go to state 53
    INC             shift and go to state 96
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 85
    THIS            shift and go to state 84
    SUPER           shift and go to state 82
    (               shift and go to state 75
    NEW             shift and go to state 70
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 69
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 76
    TRUE            shift and go to state 86
    FALSE           shift and go to state 88

    field_access                   shift and go to state 80
    primary                        shift and go to state 67
    var_decl                       shift and go to state 89
    stmt_expr                      shift and go to state 77
    literal                        shift and go to state 78
    array_access                   shift and go to state 72
    lhs                            shift and go to state 92
    stmt                           shift and go to state 185
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 94
    block                          shift and go to state 95

state 185

    (41) stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .

    }               reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    IF              reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    WHILE           reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    FOR             reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    RETURN          reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    BREAK           reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    CONTINUE        reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    {               reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    INC             reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    DEC             reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    INT             reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    FLOAT           reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    ID              reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    THIS            reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    SUPER           reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    (               reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    NEW             reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    INT_CONST       reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    NULL            reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    TRUE            reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    FALSE           reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)
    ELSE            reduce using rule 41 (stmt -> FOR ( stmt_expr ; expr ; stmt_expr ) stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 107 resolved as shift
WARNING: shift/reduce conflict for [ in state 108 resolved as shift
WARNING: shift/reduce conflict for + in state 110 resolved as shift
WARNING: shift/reduce conflict for - in state 110 resolved as shift
WARNING: shift/reduce conflict for THIS in state 111 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 111 resolved as shift
WARNING: shift/reduce conflict for ( in state 111 resolved as shift
WARNING: shift/reduce conflict for NEW in state 111 resolved as shift
WARNING: shift/reduce conflict for INC in state 111 resolved as shift
WARNING: shift/reduce conflict for DEC in state 111 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 111 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 111 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 111 resolved as shift
WARNING: shift/reduce conflict for NULL in state 111 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 111 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 111 resolved as shift
WARNING: shift/reduce conflict for ID in state 111 resolved as shift
WARNING: shift/reduce conflict for INC in state 112 resolved as shift
WARNING: shift/reduce conflict for DEC in state 112 resolved as shift
WARNING: shift/reduce conflict for + in state 129 resolved as shift
WARNING: shift/reduce conflict for - in state 129 resolved as shift
WARNING: shift/reduce conflict for * in state 129 resolved as shift
WARNING: shift/reduce conflict for / in state 129 resolved as shift
WARNING: shift/reduce conflict for AND in state 129 resolved as shift
WARNING: shift/reduce conflict for OR in state 129 resolved as shift
WARNING: shift/reduce conflict for EQL in state 129 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 129 resolved as shift
WARNING: shift/reduce conflict for < in state 129 resolved as shift
WARNING: shift/reduce conflict for > in state 129 resolved as shift
WARNING: shift/reduce conflict for LE in state 129 resolved as shift
WARNING: shift/reduce conflict for GE in state 129 resolved as shift
WARNING: shift/reduce conflict for + in state 147 resolved as shift
WARNING: shift/reduce conflict for - in state 147 resolved as shift
WARNING: shift/reduce conflict for + in state 159 resolved as shift
WARNING: shift/reduce conflict for - in state 159 resolved as shift
WARNING: shift/reduce conflict for * in state 159 resolved as shift
WARNING: shift/reduce conflict for / in state 159 resolved as shift
WARNING: shift/reduce conflict for AND in state 159 resolved as shift
WARNING: shift/reduce conflict for OR in state 159 resolved as shift
WARNING: shift/reduce conflict for EQL in state 159 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 159 resolved as shift
WARNING: shift/reduce conflict for < in state 159 resolved as shift
WARNING: shift/reduce conflict for > in state 159 resolved as shift
WARNING: shift/reduce conflict for LE in state 159 resolved as shift
WARNING: shift/reduce conflict for GE in state 159 resolved as shift
WARNING: shift/reduce conflict for + in state 163 resolved as shift
WARNING: shift/reduce conflict for - in state 163 resolved as shift
WARNING: shift/reduce conflict for * in state 163 resolved as shift
WARNING: shift/reduce conflict for / in state 163 resolved as shift
WARNING: shift/reduce conflict for AND in state 163 resolved as shift
WARNING: shift/reduce conflict for OR in state 163 resolved as shift
WARNING: shift/reduce conflict for EQL in state 163 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 163 resolved as shift
WARNING: shift/reduce conflict for < in state 163 resolved as shift
WARNING: shift/reduce conflict for > in state 163 resolved as shift
WARNING: shift/reduce conflict for LE in state 163 resolved as shift
WARNING: shift/reduce conflict for GE in state 163 resolved as shift
WARNING: shift/reduce conflict for + in state 164 resolved as shift
WARNING: shift/reduce conflict for - in state 164 resolved as shift
WARNING: shift/reduce conflict for * in state 164 resolved as shift
WARNING: shift/reduce conflict for / in state 164 resolved as shift
WARNING: shift/reduce conflict for AND in state 164 resolved as shift
WARNING: shift/reduce conflict for OR in state 164 resolved as shift
WARNING: shift/reduce conflict for EQL in state 164 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 164 resolved as shift
WARNING: shift/reduce conflict for < in state 164 resolved as shift
WARNING: shift/reduce conflict for > in state 164 resolved as shift
WARNING: shift/reduce conflict for LE in state 164 resolved as shift
WARNING: shift/reduce conflict for GE in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 178 resolved as shift
