Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> program class_decl
Rule 2     program -> empty
Rule 3     class_decl -> CLASS ID { class_body_decls }
Rule 4     class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls }
Rule 5     class_body_decls -> class_body_decls class_body_decl
Rule 6     class_body_decls -> class_body_decl
Rule 7     class_body_decl -> field_decl
Rule 8     class_body_decl -> method_decl
Rule 9     class_body_decl -> constructor_decl
Rule 10    field_decl -> modifier var_decl
Rule 11    modifier -> access class_member
Rule 12    access -> PUBLIC
Rule 13    access -> PRIVATE
Rule 14    access -> empty
Rule 15    class_member -> STATIC
Rule 16    class_member -> empty
Rule 17    var_decl -> type variables
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variables -> variables , variable
Rule 23    variables -> variable
Rule 24    variable -> variable [ ]
Rule 25    variable -> ID
Rule 26    method_decl -> modifier ( all_type ) ID ( formals ) block
Rule 27    method_decl -> modifier ( all_type ) ID ( ) block
Rule 28    all_type -> type
Rule 29    all_type -> VOID
Rule 30    constructor_decl -> modifier ID ( formals ) block
Rule 31    constructor_decl -> modifier ID ( ) block
Rule 32    formals -> formals , formal_param
Rule 33    formals -> formal_param
Rule 34    formal_param -> type variable
Rule 35    block -> { stmts }
Rule 36    stmts -> stmts stmt
Rule 37    stmts -> empty
Rule 38    stmt -> IF ( expr ) stmt
Rule 39    stmt -> IF ( expr ) stmt ELSE stmt
Rule 40    stmt -> WHILE ( expr ) stmt
Rule 41    stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
Rule 42    stmt -> RETURN has_expr ;
Rule 43    stmt -> stmt_expr ;
Rule 44    stmt -> BREAK ;
Rule 45    stmt -> CONTINUE ;
Rule 46    stmt -> block
Rule 47    stmt -> var_decl
Rule 48    stmt -> ;
Rule 49    has_stmt_expr -> stmt_expr
Rule 50    has_stmt_expr -> empty
Rule 51    has_expr -> expr
Rule 52    has_expr -> empty
Rule 53    exprs -> exprs expr
Rule 54    exprs -> expr
Rule 55    literal -> INT_CONST
Rule 56    literal -> FLOAT_CONST
Rule 57    literal -> STRING_CONST
Rule 58    literal -> NULL
Rule 59    literal -> TRUE
Rule 60    literal -> FALSE
Rule 61    primary -> literal
Rule 62    primary -> THIS
Rule 63    primary -> SUPER
Rule 64    primary -> ( expr )
Rule 65    primary -> NEW ID ( has_arguments )
Rule 66    primary -> lhs
Rule 67    primary -> method_invocation
Rule 68    has_arguments -> arguments
Rule 69    has_arguments -> empty
Rule 70    arguments -> arguments , expr
Rule 71    arguments -> expr
Rule 72    lhs -> field_access
Rule 73    lhs -> array_access
Rule 74    field_access -> primary . ID
Rule 75    field_access -> ID
Rule 76    array_access -> primary [ expr ]
Rule 77    method_invocation -> field_access ( has_arguments )
Rule 78    expr -> primary
Rule 79    expr -> assign
Rule 80    expr -> new_array
Rule 81    expr -> expr arith_op expr
Rule 82    expr -> expr bool_op expr
Rule 83    expr -> unary_op expr
Rule 84    assign -> lhs = expr
Rule 85    assign -> lhs INC
Rule 86    assign -> INC lhs
Rule 87    assign -> lhs DEC
Rule 88    assign -> DEC lhs
Rule 89    new_array -> new_array [ ]
Rule 90    new_array -> new_array_temp
Rule 91    new_array_temp -> new_array_temp [ expr ]
Rule 92    new_array_temp -> NEW type [ expr ]
Rule 93    arith_op -> +
Rule 94    arith_op -> -
Rule 95    arith_op -> *
Rule 96    arith_op -> /
Rule 97    bool_op -> AND
Rule 98    bool_op -> OR
Rule 99    bool_op -> EQL
Rule 100   bool_op -> UNEQL
Rule 101   bool_op -> <
Rule 102   bool_op -> >
Rule 103   bool_op -> LE
Rule 104   bool_op -> GE
Rule 105   unary_op -> +
Rule 106   unary_op -> -
Rule 107   unary_op -> !
Rule 108   stmt_expr -> assign
Rule 109   stmt_expr -> method_invocation
Rule 110   empty -> <empty>

Terminals, with rules where they appear

!                    : 107
(                    : 4 26 26 27 27 30 31 38 39 40 41 64 65 77
)                    : 4 26 26 27 27 30 31 38 39 40 41 64 65 77
*                    : 95
+                    : 93 105
,                    : 22 32 70
-                    : 94 106
.                    : 74
/                    : 96
;                    : 41 41 42 43 44 45 48
<                    : 101
=                    : 84
>                    : 102
AND                  : 97
BOOLEAN              : 20
BREAK                : 44
CLASS                : 3 4
CONTINUE             : 45
DEC                  : 87 88
DO                   : 
ELSE                 : 39
EQL                  : 99
EXTENDS              : 4
FALSE                : 60
FLOAT                : 19
FLOAT_CONST          : 56
FOR                  : 41
GE                   : 104
ID                   : 3 4 4 21 25 26 27 30 31 65 74 75
IF                   : 38 39
INC                  : 85 86
INT                  : 18
INT_CONST            : 55
LE                   : 103
NEW                  : 65 92
NULL                 : 58
OR                   : 98
PRIVATE              : 13
PUBLIC               : 12
RETURN               : 42
STATIC               : 15
STRING_CONST         : 57
SUPER                : 63
THIS                 : 62
TRUE                 : 59
UNEQL                : 100
VOID                 : 29
WHILE                : 40
[                    : 24 76 89 91 92
]                    : 24 76 89 91 92
error                : 
{                    : 3 4 35
}                    : 3 4 35

Nonterminals, with rules where they appear

access               : 11
all_type             : 26 27
arguments            : 68 70
arith_op             : 81
array_access         : 73
assign               : 79 108
block                : 26 27 30 31 46
bool_op              : 82
class_body_decl      : 5 6
class_body_decls     : 3 4 5
class_decl           : 1
class_member         : 11
constructor_decl     : 9
empty                : 2 14 16 37 50 52 69
expr                 : 38 39 40 51 53 54 64 70 71 76 81 81 82 82 83 84 91 92
exprs                : 53
field_access         : 72 77
field_decl           : 7
formal_param         : 32 33
formals              : 26 30 32
has_arguments        : 65 77
has_expr             : 41 42
has_stmt_expr        : 41 41
lhs                  : 66 84 85 86 87 88
literal              : 61
method_decl          : 8
method_invocation    : 67 109
modifier             : 10 26 27 30 31
new_array            : 80 89
new_array_temp       : 90 91
primary              : 74 76 78
program              : 1 0
stmt                 : 36 38 39 39 40 41
stmt_expr            : 43 49
stmts                : 35 36
type                 : 17 28 34 92
unary_op             : 83
var_decl             : 10 47
variable             : 22 23 24 34
variables            : 17 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program class_decl
    (2) program -> . empty
    (110) empty -> .

    CLASS           reduce using rule 110 (empty -> .)
    $end            reduce using rule 110 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (1) program -> program . class_decl
    (3) class_decl -> . CLASS ID { class_body_decls }
    (4) class_decl -> . CLASS ID ( EXTENDS ID ) { class_body_decls }

    CLASS           shift and go to state 3

    class_decl                     shift and go to state 4

state 2

    (2) program -> empty .

    CLASS           reduce using rule 2 (program -> empty .)
    $end            reduce using rule 2 (program -> empty .)


state 3

    (3) class_decl -> CLASS . ID { class_body_decls }
    (4) class_decl -> CLASS . ID ( EXTENDS ID ) { class_body_decls }

    ID              shift and go to state 5


state 4

    (1) program -> program class_decl .

    CLASS           reduce using rule 1 (program -> program class_decl .)
    $end            reduce using rule 1 (program -> program class_decl .)


state 5

    (3) class_decl -> CLASS ID . { class_body_decls }
    (4) class_decl -> CLASS ID . ( EXTENDS ID ) { class_body_decls }

    {               shift and go to state 7
    (               shift and go to state 6


state 6

    (4) class_decl -> CLASS ID ( . EXTENDS ID ) { class_body_decls }

    EXTENDS         shift and go to state 8


state 7

    (3) class_decl -> CLASS ID { . class_body_decls }
    (5) class_body_decls -> . class_body_decls class_body_decl
    (6) class_body_decls -> . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (110) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 110 (empty -> .)
    (               reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)

    class_body_decl                shift and go to state 9
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17
    class_body_decls               shift and go to state 18

state 8

    (4) class_decl -> CLASS ID ( EXTENDS . ID ) { class_body_decls }

    ID              shift and go to state 19


state 9

    (6) class_body_decls -> class_body_decl .

    }               reduce using rule 6 (class_body_decls -> class_body_decl .)
    PUBLIC          reduce using rule 6 (class_body_decls -> class_body_decl .)
    PRIVATE         reduce using rule 6 (class_body_decls -> class_body_decl .)
    (               reduce using rule 6 (class_body_decls -> class_body_decl .)
    ID              reduce using rule 6 (class_body_decls -> class_body_decl .)
    INT             reduce using rule 6 (class_body_decls -> class_body_decl .)
    FLOAT           reduce using rule 6 (class_body_decls -> class_body_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decls -> class_body_decl .)
    STATIC          reduce using rule 6 (class_body_decls -> class_body_decl .)


state 10

    (13) access -> PRIVATE .

    STATIC          reduce using rule 13 (access -> PRIVATE .)
    (               reduce using rule 13 (access -> PRIVATE .)
    ID              reduce using rule 13 (access -> PRIVATE .)
    INT             reduce using rule 13 (access -> PRIVATE .)
    FLOAT           reduce using rule 13 (access -> PRIVATE .)
    BOOLEAN         reduce using rule 13 (access -> PRIVATE .)


state 11

    (7) class_body_decl -> field_decl .

    }               reduce using rule 7 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 7 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> field_decl .)
    (               reduce using rule 7 (class_body_decl -> field_decl .)
    ID              reduce using rule 7 (class_body_decl -> field_decl .)
    INT             reduce using rule 7 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> field_decl .)


state 12

    (9) class_body_decl -> constructor_decl .

    }               reduce using rule 9 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> constructor_decl .)
    (               reduce using rule 9 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 9 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 9 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> constructor_decl .)


state 13

    (8) class_body_decl -> method_decl .

    }               reduce using rule 8 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl -> method_decl .)
    (               reduce using rule 8 (class_body_decl -> method_decl .)
    ID              reduce using rule 8 (class_body_decl -> method_decl .)
    INT             reduce using rule 8 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 8 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 8 (class_body_decl -> method_decl .)


state 14

    (11) modifier -> access . class_member
    (15) class_member -> . STATIC
    (16) class_member -> . empty
    (110) empty -> .

    STATIC          shift and go to state 20
    (               reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)

    class_member                   shift and go to state 21
    empty                          shift and go to state 22

state 15

    (14) access -> empty .

    STATIC          reduce using rule 14 (access -> empty .)
    (               reduce using rule 14 (access -> empty .)
    ID              reduce using rule 14 (access -> empty .)
    INT             reduce using rule 14 (access -> empty .)
    FLOAT           reduce using rule 14 (access -> empty .)
    BOOLEAN         reduce using rule 14 (access -> empty .)


state 16

    (12) access -> PUBLIC .

    STATIC          reduce using rule 12 (access -> PUBLIC .)
    (               reduce using rule 12 (access -> PUBLIC .)
    ID              reduce using rule 12 (access -> PUBLIC .)
    INT             reduce using rule 12 (access -> PUBLIC .)
    FLOAT           reduce using rule 12 (access -> PUBLIC .)
    BOOLEAN         reduce using rule 12 (access -> PUBLIC .)


state 17

    (10) field_decl -> modifier . var_decl
    (26) method_decl -> modifier . ( all_type ) ID ( formals ) block
    (27) method_decl -> modifier . ( all_type ) ID ( ) block
    (30) constructor_decl -> modifier . ID ( formals ) block
    (31) constructor_decl -> modifier . ID ( ) block
    (17) var_decl -> . type variables
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    (               shift and go to state 23
    ID              shift and go to state 29
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27

    var_decl                       shift and go to state 25
    type                           shift and go to state 28

state 18

    (3) class_decl -> CLASS ID { class_body_decls . }
    (5) class_body_decls -> class_body_decls . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (110) empty -> .

    }               shift and go to state 31
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 110 (empty -> .)
    (               reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)

    class_body_decl                shift and go to state 30
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17

state 19

    (4) class_decl -> CLASS ID ( EXTENDS ID . ) { class_body_decls }

    )               shift and go to state 32


state 20

    (15) class_member -> STATIC .

    (               reduce using rule 15 (class_member -> STATIC .)
    ID              reduce using rule 15 (class_member -> STATIC .)
    INT             reduce using rule 15 (class_member -> STATIC .)
    FLOAT           reduce using rule 15 (class_member -> STATIC .)
    BOOLEAN         reduce using rule 15 (class_member -> STATIC .)


state 21

    (11) modifier -> access class_member .

    (               reduce using rule 11 (modifier -> access class_member .)
    ID              reduce using rule 11 (modifier -> access class_member .)
    INT             reduce using rule 11 (modifier -> access class_member .)
    FLOAT           reduce using rule 11 (modifier -> access class_member .)
    BOOLEAN         reduce using rule 11 (modifier -> access class_member .)


state 22

    (16) class_member -> empty .

    (               reduce using rule 16 (class_member -> empty .)
    ID              reduce using rule 16 (class_member -> empty .)
    INT             reduce using rule 16 (class_member -> empty .)
    FLOAT           reduce using rule 16 (class_member -> empty .)
    BOOLEAN         reduce using rule 16 (class_member -> empty .)


state 23

    (26) method_decl -> modifier ( . all_type ) ID ( formals ) block
    (27) method_decl -> modifier ( . all_type ) ID ( ) block
    (28) all_type -> . type
    (29) all_type -> . VOID
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 33
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    type                           shift and go to state 34
    all_type                       shift and go to state 35

state 24

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)
    [               reduce using rule 19 (type -> FLOAT .)
    )               reduce using rule 19 (type -> FLOAT .)


state 25

    (10) field_decl -> modifier var_decl .

    }               reduce using rule 10 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 10 (field_decl -> modifier var_decl .)
    (               reduce using rule 10 (field_decl -> modifier var_decl .)
    ID              reduce using rule 10 (field_decl -> modifier var_decl .)
    INT             reduce using rule 10 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 10 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 10 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 10 (field_decl -> modifier var_decl .)


state 26

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)
    [               reduce using rule 18 (type -> INT .)
    )               reduce using rule 18 (type -> INT .)


state 27

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)
    [               reduce using rule 20 (type -> BOOLEAN .)
    )               reduce using rule 20 (type -> BOOLEAN .)


state 28

    (17) var_decl -> type . variables
    (22) variables -> . variables , variable
    (23) variables -> . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 38
    variables                      shift and go to state 37

state 29

    (30) constructor_decl -> modifier ID . ( formals ) block
    (31) constructor_decl -> modifier ID . ( ) block
    (21) type -> ID .

    (               shift and go to state 40
    ID              reduce using rule 21 (type -> ID .)


state 30

    (5) class_body_decls -> class_body_decls class_body_decl .

    }               reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    PUBLIC          reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    PRIVATE         reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    (               reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    ID              reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    INT             reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    FLOAT           reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    BOOLEAN         reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)
    STATIC          reduce using rule 5 (class_body_decls -> class_body_decls class_body_decl .)


state 31

    (3) class_decl -> CLASS ID { class_body_decls } .

    CLASS           reduce using rule 3 (class_decl -> CLASS ID { class_body_decls } .)
    $end            reduce using rule 3 (class_decl -> CLASS ID { class_body_decls } .)


state 32

    (4) class_decl -> CLASS ID ( EXTENDS ID ) . { class_body_decls }

    {               shift and go to state 41


state 33

    (29) all_type -> VOID .

    )               reduce using rule 29 (all_type -> VOID .)


state 34

    (28) all_type -> type .

    )               reduce using rule 28 (all_type -> type .)


state 35

    (26) method_decl -> modifier ( all_type . ) ID ( formals ) block
    (27) method_decl -> modifier ( all_type . ) ID ( ) block

    )               shift and go to state 42


state 36

    (21) type -> ID .

    )               reduce using rule 21 (type -> ID .)
    ID              reduce using rule 21 (type -> ID .)


state 37

    (17) var_decl -> type variables .
    (22) variables -> variables . , variable

    }               reduce using rule 17 (var_decl -> type variables .)
    IF              reduce using rule 17 (var_decl -> type variables .)
    WHILE           reduce using rule 17 (var_decl -> type variables .)
    FOR             reduce using rule 17 (var_decl -> type variables .)
    RETURN          reduce using rule 17 (var_decl -> type variables .)
    BREAK           reduce using rule 17 (var_decl -> type variables .)
    CONTINUE        reduce using rule 17 (var_decl -> type variables .)
    ;               reduce using rule 17 (var_decl -> type variables .)
    {               reduce using rule 17 (var_decl -> type variables .)
    INC             reduce using rule 17 (var_decl -> type variables .)
    DEC             reduce using rule 17 (var_decl -> type variables .)
    INT             reduce using rule 17 (var_decl -> type variables .)
    FLOAT           reduce using rule 17 (var_decl -> type variables .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variables .)
    ID              reduce using rule 17 (var_decl -> type variables .)
    THIS            reduce using rule 17 (var_decl -> type variables .)
    SUPER           reduce using rule 17 (var_decl -> type variables .)
    (               reduce using rule 17 (var_decl -> type variables .)
    NEW             reduce using rule 17 (var_decl -> type variables .)
    INT_CONST       reduce using rule 17 (var_decl -> type variables .)
    FLOAT_CONST     reduce using rule 17 (var_decl -> type variables .)
    STRING_CONST    reduce using rule 17 (var_decl -> type variables .)
    NULL            reduce using rule 17 (var_decl -> type variables .)
    TRUE            reduce using rule 17 (var_decl -> type variables .)
    FALSE           reduce using rule 17 (var_decl -> type variables .)
    ELSE            reduce using rule 17 (var_decl -> type variables .)
    PUBLIC          reduce using rule 17 (var_decl -> type variables .)
    PRIVATE         reduce using rule 17 (var_decl -> type variables .)
    STATIC          reduce using rule 17 (var_decl -> type variables .)
    ,               shift and go to state 43


state 38

    (23) variables -> variable .
    (24) variable -> variable . [ ]

    ,               reduce using rule 23 (variables -> variable .)
    }               reduce using rule 23 (variables -> variable .)
    PUBLIC          reduce using rule 23 (variables -> variable .)
    PRIVATE         reduce using rule 23 (variables -> variable .)
    (               reduce using rule 23 (variables -> variable .)
    ID              reduce using rule 23 (variables -> variable .)
    INT             reduce using rule 23 (variables -> variable .)
    FLOAT           reduce using rule 23 (variables -> variable .)
    BOOLEAN         reduce using rule 23 (variables -> variable .)
    STATIC          reduce using rule 23 (variables -> variable .)
    IF              reduce using rule 23 (variables -> variable .)
    WHILE           reduce using rule 23 (variables -> variable .)
    FOR             reduce using rule 23 (variables -> variable .)
    RETURN          reduce using rule 23 (variables -> variable .)
    BREAK           reduce using rule 23 (variables -> variable .)
    CONTINUE        reduce using rule 23 (variables -> variable .)
    ;               reduce using rule 23 (variables -> variable .)
    {               reduce using rule 23 (variables -> variable .)
    INC             reduce using rule 23 (variables -> variable .)
    DEC             reduce using rule 23 (variables -> variable .)
    THIS            reduce using rule 23 (variables -> variable .)
    SUPER           reduce using rule 23 (variables -> variable .)
    NEW             reduce using rule 23 (variables -> variable .)
    INT_CONST       reduce using rule 23 (variables -> variable .)
    FLOAT_CONST     reduce using rule 23 (variables -> variable .)
    STRING_CONST    reduce using rule 23 (variables -> variable .)
    NULL            reduce using rule 23 (variables -> variable .)
    TRUE            reduce using rule 23 (variables -> variable .)
    FALSE           reduce using rule 23 (variables -> variable .)
    ELSE            reduce using rule 23 (variables -> variable .)
    [               shift and go to state 44


state 39

    (25) variable -> ID .

    [               reduce using rule 25 (variable -> ID .)
    ,               reduce using rule 25 (variable -> ID .)
    }               reduce using rule 25 (variable -> ID .)
    PUBLIC          reduce using rule 25 (variable -> ID .)
    PRIVATE         reduce using rule 25 (variable -> ID .)
    (               reduce using rule 25 (variable -> ID .)
    ID              reduce using rule 25 (variable -> ID .)
    INT             reduce using rule 25 (variable -> ID .)
    FLOAT           reduce using rule 25 (variable -> ID .)
    BOOLEAN         reduce using rule 25 (variable -> ID .)
    STATIC          reduce using rule 25 (variable -> ID .)
    IF              reduce using rule 25 (variable -> ID .)
    WHILE           reduce using rule 25 (variable -> ID .)
    FOR             reduce using rule 25 (variable -> ID .)
    RETURN          reduce using rule 25 (variable -> ID .)
    BREAK           reduce using rule 25 (variable -> ID .)
    CONTINUE        reduce using rule 25 (variable -> ID .)
    ;               reduce using rule 25 (variable -> ID .)
    {               reduce using rule 25 (variable -> ID .)
    INC             reduce using rule 25 (variable -> ID .)
    DEC             reduce using rule 25 (variable -> ID .)
    THIS            reduce using rule 25 (variable -> ID .)
    SUPER           reduce using rule 25 (variable -> ID .)
    NEW             reduce using rule 25 (variable -> ID .)
    INT_CONST       reduce using rule 25 (variable -> ID .)
    FLOAT_CONST     reduce using rule 25 (variable -> ID .)
    STRING_CONST    reduce using rule 25 (variable -> ID .)
    NULL            reduce using rule 25 (variable -> ID .)
    TRUE            reduce using rule 25 (variable -> ID .)
    FALSE           reduce using rule 25 (variable -> ID .)
    ELSE            reduce using rule 25 (variable -> ID .)
    )               reduce using rule 25 (variable -> ID .)


state 40

    (30) constructor_decl -> modifier ID ( . formals ) block
    (31) constructor_decl -> modifier ID ( . ) block
    (32) formals -> . formals , formal_param
    (33) formals -> . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               shift and go to state 46
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 45
    type                           shift and go to state 47
    formals                        shift and go to state 48

state 41

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { . class_body_decls }
    (5) class_body_decls -> . class_body_decls class_body_decl
    (6) class_body_decls -> . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (110) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 110 (empty -> .)
    (               reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)

    class_body_decl                shift and go to state 9
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17
    class_body_decls               shift and go to state 49

state 42

    (26) method_decl -> modifier ( all_type ) . ID ( formals ) block
    (27) method_decl -> modifier ( all_type ) . ID ( ) block

    ID              shift and go to state 50


state 43

    (22) variables -> variables , . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 51

state 44

    (24) variable -> variable [ . ]

    ]               shift and go to state 52


state 45

    (33) formals -> formal_param .

    )               reduce using rule 33 (formals -> formal_param .)
    ,               reduce using rule 33 (formals -> formal_param .)


state 46

    (31) constructor_decl -> modifier ID ( ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 54

state 47

    (34) formal_param -> type . variable
    (24) variable -> . variable [ ]
    (25) variable -> . ID

    ID              shift and go to state 39

    variable                       shift and go to state 55

state 48

    (30) constructor_decl -> modifier ID ( formals . ) block
    (32) formals -> formals . , formal_param

    )               shift and go to state 56
    ,               shift and go to state 57


state 49

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls . }
    (5) class_body_decls -> class_body_decls . class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier ( all_type ) ID ( formals ) block
    (27) method_decl -> . modifier ( all_type ) ID ( ) block
    (30) constructor_decl -> . modifier ID ( formals ) block
    (31) constructor_decl -> . modifier ID ( ) block
    (11) modifier -> . access class_member
    (12) access -> . PUBLIC
    (13) access -> . PRIVATE
    (14) access -> . empty
    (110) empty -> .

    }               shift and go to state 58
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 10
    STATIC          reduce using rule 110 (empty -> .)
    (               reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)

    class_body_decl                shift and go to state 30
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 12
    method_decl                    shift and go to state 13
    access                         shift and go to state 14
    empty                          shift and go to state 15
    modifier                       shift and go to state 17

state 50

    (26) method_decl -> modifier ( all_type ) ID . ( formals ) block
    (27) method_decl -> modifier ( all_type ) ID . ( ) block

    (               shift and go to state 59


state 51

    (22) variables -> variables , variable .
    (24) variable -> variable . [ ]

    ,               reduce using rule 22 (variables -> variables , variable .)
    }               reduce using rule 22 (variables -> variables , variable .)
    PUBLIC          reduce using rule 22 (variables -> variables , variable .)
    PRIVATE         reduce using rule 22 (variables -> variables , variable .)
    (               reduce using rule 22 (variables -> variables , variable .)
    ID              reduce using rule 22 (variables -> variables , variable .)
    INT             reduce using rule 22 (variables -> variables , variable .)
    FLOAT           reduce using rule 22 (variables -> variables , variable .)
    BOOLEAN         reduce using rule 22 (variables -> variables , variable .)
    STATIC          reduce using rule 22 (variables -> variables , variable .)
    IF              reduce using rule 22 (variables -> variables , variable .)
    WHILE           reduce using rule 22 (variables -> variables , variable .)
    FOR             reduce using rule 22 (variables -> variables , variable .)
    RETURN          reduce using rule 22 (variables -> variables , variable .)
    BREAK           reduce using rule 22 (variables -> variables , variable .)
    CONTINUE        reduce using rule 22 (variables -> variables , variable .)
    ;               reduce using rule 22 (variables -> variables , variable .)
    {               reduce using rule 22 (variables -> variables , variable .)
    INC             reduce using rule 22 (variables -> variables , variable .)
    DEC             reduce using rule 22 (variables -> variables , variable .)
    THIS            reduce using rule 22 (variables -> variables , variable .)
    SUPER           reduce using rule 22 (variables -> variables , variable .)
    NEW             reduce using rule 22 (variables -> variables , variable .)
    INT_CONST       reduce using rule 22 (variables -> variables , variable .)
    FLOAT_CONST     reduce using rule 22 (variables -> variables , variable .)
    STRING_CONST    reduce using rule 22 (variables -> variables , variable .)
    NULL            reduce using rule 22 (variables -> variables , variable .)
    TRUE            reduce using rule 22 (variables -> variables , variable .)
    FALSE           reduce using rule 22 (variables -> variables , variable .)
    ELSE            reduce using rule 22 (variables -> variables , variable .)
    [               shift and go to state 44


state 52

    (24) variable -> variable [ ] .

    [               reduce using rule 24 (variable -> variable [ ] .)
    ,               reduce using rule 24 (variable -> variable [ ] .)
    }               reduce using rule 24 (variable -> variable [ ] .)
    PUBLIC          reduce using rule 24 (variable -> variable [ ] .)
    PRIVATE         reduce using rule 24 (variable -> variable [ ] .)
    (               reduce using rule 24 (variable -> variable [ ] .)
    ID              reduce using rule 24 (variable -> variable [ ] .)
    INT             reduce using rule 24 (variable -> variable [ ] .)
    FLOAT           reduce using rule 24 (variable -> variable [ ] .)
    BOOLEAN         reduce using rule 24 (variable -> variable [ ] .)
    STATIC          reduce using rule 24 (variable -> variable [ ] .)
    IF              reduce using rule 24 (variable -> variable [ ] .)
    WHILE           reduce using rule 24 (variable -> variable [ ] .)
    FOR             reduce using rule 24 (variable -> variable [ ] .)
    RETURN          reduce using rule 24 (variable -> variable [ ] .)
    BREAK           reduce using rule 24 (variable -> variable [ ] .)
    CONTINUE        reduce using rule 24 (variable -> variable [ ] .)
    ;               reduce using rule 24 (variable -> variable [ ] .)
    {               reduce using rule 24 (variable -> variable [ ] .)
    INC             reduce using rule 24 (variable -> variable [ ] .)
    DEC             reduce using rule 24 (variable -> variable [ ] .)
    THIS            reduce using rule 24 (variable -> variable [ ] .)
    SUPER           reduce using rule 24 (variable -> variable [ ] .)
    NEW             reduce using rule 24 (variable -> variable [ ] .)
    INT_CONST       reduce using rule 24 (variable -> variable [ ] .)
    FLOAT_CONST     reduce using rule 24 (variable -> variable [ ] .)
    STRING_CONST    reduce using rule 24 (variable -> variable [ ] .)
    NULL            reduce using rule 24 (variable -> variable [ ] .)
    TRUE            reduce using rule 24 (variable -> variable [ ] .)
    FALSE           reduce using rule 24 (variable -> variable [ ] .)
    ELSE            reduce using rule 24 (variable -> variable [ ] .)
    )               reduce using rule 24 (variable -> variable [ ] .)


state 53

    (35) block -> { . stmts }
    (36) stmts -> . stmts stmt
    (37) stmts -> . empty
    (110) empty -> .

    }               reduce using rule 110 (empty -> .)
    IF              reduce using rule 110 (empty -> .)
    WHILE           reduce using rule 110 (empty -> .)
    FOR             reduce using rule 110 (empty -> .)
    RETURN          reduce using rule 110 (empty -> .)
    BREAK           reduce using rule 110 (empty -> .)
    CONTINUE        reduce using rule 110 (empty -> .)
    ;               reduce using rule 110 (empty -> .)
    {               reduce using rule 110 (empty -> .)
    INC             reduce using rule 110 (empty -> .)
    DEC             reduce using rule 110 (empty -> .)
    INT             reduce using rule 110 (empty -> .)
    FLOAT           reduce using rule 110 (empty -> .)
    BOOLEAN         reduce using rule 110 (empty -> .)
    ID              reduce using rule 110 (empty -> .)
    THIS            reduce using rule 110 (empty -> .)
    SUPER           reduce using rule 110 (empty -> .)
    (               reduce using rule 110 (empty -> .)
    NEW             reduce using rule 110 (empty -> .)
    INT_CONST       reduce using rule 110 (empty -> .)
    FLOAT_CONST     reduce using rule 110 (empty -> .)
    STRING_CONST    reduce using rule 110 (empty -> .)
    NULL            reduce using rule 110 (empty -> .)
    TRUE            reduce using rule 110 (empty -> .)
    FALSE           reduce using rule 110 (empty -> .)

    stmts                          shift and go to state 60
    empty                          shift and go to state 61

state 54

    (31) constructor_decl -> modifier ID ( ) block .

    }               reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    PUBLIC          reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    PRIVATE         reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    (               reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    ID              reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    INT             reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    FLOAT           reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    BOOLEAN         reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)
    STATIC          reduce using rule 31 (constructor_decl -> modifier ID ( ) block .)


state 55

    (34) formal_param -> type variable .
    (24) variable -> variable . [ ]

    )               reduce using rule 34 (formal_param -> type variable .)
    ,               reduce using rule 34 (formal_param -> type variable .)
    [               shift and go to state 44


state 56

    (30) constructor_decl -> modifier ID ( formals ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 62

state 57

    (32) formals -> formals , . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 63
    type                           shift and go to state 47

state 58

    (4) class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .)
    $end            reduce using rule 4 (class_decl -> CLASS ID ( EXTENDS ID ) { class_body_decls } .)


state 59

    (26) method_decl -> modifier ( all_type ) ID ( . formals ) block
    (27) method_decl -> modifier ( all_type ) ID ( . ) block
    (32) formals -> . formals , formal_param
    (33) formals -> . formal_param
    (34) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               shift and go to state 64
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 36

    formal_param                   shift and go to state 45
    type                           shift and go to state 47
    formals                        shift and go to state 65

state 60

    (35) block -> { stmts . }
    (36) stmts -> stmts . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (42) stmt -> . RETURN has_expr ;
    (43) stmt -> . stmt_expr ;
    (44) stmt -> . BREAK ;
    (45) stmt -> . CONTINUE ;
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (48) stmt -> . ;
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    }               shift and go to state 94
    IF              shift and go to state 88
    WHILE           shift and go to state 67
    FOR             shift and go to state 82
    RETURN          shift and go to state 70
    BREAK           shift and go to state 91
    CONTINUE        shift and go to state 92
    ;               shift and go to state 80
    {               shift and go to state 53
    INC             shift and go to state 97
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 86
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt                           shift and go to state 84
    stmt_expr                      shift and go to state 77
    array_access                   shift and go to state 72
    lhs                            shift and go to state 93
    var_decl                       shift and go to state 90
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 95
    block                          shift and go to state 96

state 61

    (37) stmts -> empty .

    }               reduce using rule 37 (stmts -> empty .)
    IF              reduce using rule 37 (stmts -> empty .)
    WHILE           reduce using rule 37 (stmts -> empty .)
    FOR             reduce using rule 37 (stmts -> empty .)
    RETURN          reduce using rule 37 (stmts -> empty .)
    BREAK           reduce using rule 37 (stmts -> empty .)
    CONTINUE        reduce using rule 37 (stmts -> empty .)
    ;               reduce using rule 37 (stmts -> empty .)
    {               reduce using rule 37 (stmts -> empty .)
    INC             reduce using rule 37 (stmts -> empty .)
    DEC             reduce using rule 37 (stmts -> empty .)
    INT             reduce using rule 37 (stmts -> empty .)
    FLOAT           reduce using rule 37 (stmts -> empty .)
    BOOLEAN         reduce using rule 37 (stmts -> empty .)
    ID              reduce using rule 37 (stmts -> empty .)
    THIS            reduce using rule 37 (stmts -> empty .)
    SUPER           reduce using rule 37 (stmts -> empty .)
    (               reduce using rule 37 (stmts -> empty .)
    NEW             reduce using rule 37 (stmts -> empty .)
    INT_CONST       reduce using rule 37 (stmts -> empty .)
    FLOAT_CONST     reduce using rule 37 (stmts -> empty .)
    STRING_CONST    reduce using rule 37 (stmts -> empty .)
    NULL            reduce using rule 37 (stmts -> empty .)
    TRUE            reduce using rule 37 (stmts -> empty .)
    FALSE           reduce using rule 37 (stmts -> empty .)


state 62

    (30) constructor_decl -> modifier ID ( formals ) block .

    }               reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    (               reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)
    STATIC          reduce using rule 30 (constructor_decl -> modifier ID ( formals ) block .)


state 63

    (32) formals -> formals , formal_param .

    )               reduce using rule 32 (formals -> formals , formal_param .)
    ,               reduce using rule 32 (formals -> formals , formal_param .)


state 64

    (27) method_decl -> modifier ( all_type ) ID ( ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 98

state 65

    (26) method_decl -> modifier ( all_type ) ID ( formals . ) block
    (32) formals -> formals . , formal_param

    )               shift and go to state 99
    ,               shift and go to state 57


state 66

    (74) field_access -> primary . . ID
    (76) array_access -> primary . [ expr ]

    .               shift and go to state 100
    [               shift and go to state 101


state 67

    (40) stmt -> WHILE . ( expr ) stmt

    (               shift and go to state 102


state 68

    (56) literal -> FLOAT_CONST .

    .               reduce using rule 56 (literal -> FLOAT_CONST .)
    [               reduce using rule 56 (literal -> FLOAT_CONST .)
    +               reduce using rule 56 (literal -> FLOAT_CONST .)
    -               reduce using rule 56 (literal -> FLOAT_CONST .)
    *               reduce using rule 56 (literal -> FLOAT_CONST .)
    /               reduce using rule 56 (literal -> FLOAT_CONST .)
    AND             reduce using rule 56 (literal -> FLOAT_CONST .)
    OR              reduce using rule 56 (literal -> FLOAT_CONST .)
    EQL             reduce using rule 56 (literal -> FLOAT_CONST .)
    UNEQL           reduce using rule 56 (literal -> FLOAT_CONST .)
    <               reduce using rule 56 (literal -> FLOAT_CONST .)
    >               reduce using rule 56 (literal -> FLOAT_CONST .)
    LE              reduce using rule 56 (literal -> FLOAT_CONST .)
    GE              reduce using rule 56 (literal -> FLOAT_CONST .)
    ,               reduce using rule 56 (literal -> FLOAT_CONST .)
    )               reduce using rule 56 (literal -> FLOAT_CONST .)
    ;               reduce using rule 56 (literal -> FLOAT_CONST .)
    ]               reduce using rule 56 (literal -> FLOAT_CONST .)


state 69

    (65) primary -> NEW . ID ( has_arguments )

    ID              shift and go to state 103


state 70

    (42) stmt -> RETURN . has_expr ;
    (51) has_expr -> . expr
    (52) has_expr -> . empty
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (110) empty -> .
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    ;               reduce using rule 110 (empty -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 116
    literal                        shift and go to state 78
    primary                        shift and go to state 105
    has_expr                       shift and go to state 117
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119
    empty                          shift and go to state 112

state 71

    (88) assign -> DEC . lhs
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (77) method_invocation -> . field_access ( has_arguments )

    ID              shift and go to state 115
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 113
    primary                        shift and go to state 66
    literal                        shift and go to state 78
    lhs                            shift and go to state 120
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72

state 72

    (73) lhs -> array_access .

    =               reduce using rule 73 (lhs -> array_access .)
    INC             reduce using rule 73 (lhs -> array_access .)
    DEC             reduce using rule 73 (lhs -> array_access .)
    .               reduce using rule 73 (lhs -> array_access .)
    [               reduce using rule 73 (lhs -> array_access .)
    +               reduce using rule 73 (lhs -> array_access .)
    -               reduce using rule 73 (lhs -> array_access .)
    *               reduce using rule 73 (lhs -> array_access .)
    /               reduce using rule 73 (lhs -> array_access .)
    AND             reduce using rule 73 (lhs -> array_access .)
    OR              reduce using rule 73 (lhs -> array_access .)
    EQL             reduce using rule 73 (lhs -> array_access .)
    UNEQL           reduce using rule 73 (lhs -> array_access .)
    <               reduce using rule 73 (lhs -> array_access .)
    >               reduce using rule 73 (lhs -> array_access .)
    LE              reduce using rule 73 (lhs -> array_access .)
    GE              reduce using rule 73 (lhs -> array_access .)
    ,               reduce using rule 73 (lhs -> array_access .)
    )               reduce using rule 73 (lhs -> array_access .)
    ;               reduce using rule 73 (lhs -> array_access .)
    ]               reduce using rule 73 (lhs -> array_access .)


state 73

    (57) literal -> STRING_CONST .

    .               reduce using rule 57 (literal -> STRING_CONST .)
    [               reduce using rule 57 (literal -> STRING_CONST .)
    +               reduce using rule 57 (literal -> STRING_CONST .)
    -               reduce using rule 57 (literal -> STRING_CONST .)
    *               reduce using rule 57 (literal -> STRING_CONST .)
    /               reduce using rule 57 (literal -> STRING_CONST .)
    AND             reduce using rule 57 (literal -> STRING_CONST .)
    OR              reduce using rule 57 (literal -> STRING_CONST .)
    EQL             reduce using rule 57 (literal -> STRING_CONST .)
    UNEQL           reduce using rule 57 (literal -> STRING_CONST .)
    <               reduce using rule 57 (literal -> STRING_CONST .)
    >               reduce using rule 57 (literal -> STRING_CONST .)
    LE              reduce using rule 57 (literal -> STRING_CONST .)
    GE              reduce using rule 57 (literal -> STRING_CONST .)
    ,               reduce using rule 57 (literal -> STRING_CONST .)
    )               reduce using rule 57 (literal -> STRING_CONST .)
    ;               reduce using rule 57 (literal -> STRING_CONST .)
    ]               reduce using rule 57 (literal -> STRING_CONST .)


state 74

    (55) literal -> INT_CONST .

    .               reduce using rule 55 (literal -> INT_CONST .)
    [               reduce using rule 55 (literal -> INT_CONST .)
    +               reduce using rule 55 (literal -> INT_CONST .)
    -               reduce using rule 55 (literal -> INT_CONST .)
    *               reduce using rule 55 (literal -> INT_CONST .)
    /               reduce using rule 55 (literal -> INT_CONST .)
    AND             reduce using rule 55 (literal -> INT_CONST .)
    OR              reduce using rule 55 (literal -> INT_CONST .)
    EQL             reduce using rule 55 (literal -> INT_CONST .)
    UNEQL           reduce using rule 55 (literal -> INT_CONST .)
    <               reduce using rule 55 (literal -> INT_CONST .)
    >               reduce using rule 55 (literal -> INT_CONST .)
    LE              reduce using rule 55 (literal -> INT_CONST .)
    GE              reduce using rule 55 (literal -> INT_CONST .)
    ,               reduce using rule 55 (literal -> INT_CONST .)
    )               reduce using rule 55 (literal -> INT_CONST .)
    ;               reduce using rule 55 (literal -> INT_CONST .)
    ]               reduce using rule 55 (literal -> INT_CONST .)


state 75

    (58) literal -> NULL .

    .               reduce using rule 58 (literal -> NULL .)
    [               reduce using rule 58 (literal -> NULL .)
    +               reduce using rule 58 (literal -> NULL .)
    -               reduce using rule 58 (literal -> NULL .)
    *               reduce using rule 58 (literal -> NULL .)
    /               reduce using rule 58 (literal -> NULL .)
    AND             reduce using rule 58 (literal -> NULL .)
    OR              reduce using rule 58 (literal -> NULL .)
    EQL             reduce using rule 58 (literal -> NULL .)
    UNEQL           reduce using rule 58 (literal -> NULL .)
    <               reduce using rule 58 (literal -> NULL .)
    >               reduce using rule 58 (literal -> NULL .)
    LE              reduce using rule 58 (literal -> NULL .)
    GE              reduce using rule 58 (literal -> NULL .)
    ,               reduce using rule 58 (literal -> NULL .)
    )               reduce using rule 58 (literal -> NULL .)
    ;               reduce using rule 58 (literal -> NULL .)
    ]               reduce using rule 58 (literal -> NULL .)


state 76

    (64) primary -> ( . expr )
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 121
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 77

    (43) stmt -> stmt_expr . ;

    ;               shift and go to state 122


state 78

    (61) primary -> literal .

    .               reduce using rule 61 (primary -> literal .)
    [               reduce using rule 61 (primary -> literal .)
    +               reduce using rule 61 (primary -> literal .)
    -               reduce using rule 61 (primary -> literal .)
    *               reduce using rule 61 (primary -> literal .)
    /               reduce using rule 61 (primary -> literal .)
    AND             reduce using rule 61 (primary -> literal .)
    OR              reduce using rule 61 (primary -> literal .)
    EQL             reduce using rule 61 (primary -> literal .)
    UNEQL           reduce using rule 61 (primary -> literal .)
    <               reduce using rule 61 (primary -> literal .)
    >               reduce using rule 61 (primary -> literal .)
    LE              reduce using rule 61 (primary -> literal .)
    GE              reduce using rule 61 (primary -> literal .)
    ;               reduce using rule 61 (primary -> literal .)
    )               reduce using rule 61 (primary -> literal .)
    ]               reduce using rule 61 (primary -> literal .)
    ,               reduce using rule 61 (primary -> literal .)


state 79

    (109) stmt_expr -> method_invocation .
    (67) primary -> method_invocation .

    ;               reduce using rule 109 (stmt_expr -> method_invocation .)
    )               reduce using rule 109 (stmt_expr -> method_invocation .)
    .               reduce using rule 67 (primary -> method_invocation .)
    [               reduce using rule 67 (primary -> method_invocation .)


state 80

    (48) stmt -> ; .

    }               reduce using rule 48 (stmt -> ; .)
    IF              reduce using rule 48 (stmt -> ; .)
    WHILE           reduce using rule 48 (stmt -> ; .)
    FOR             reduce using rule 48 (stmt -> ; .)
    RETURN          reduce using rule 48 (stmt -> ; .)
    BREAK           reduce using rule 48 (stmt -> ; .)
    CONTINUE        reduce using rule 48 (stmt -> ; .)
    ;               reduce using rule 48 (stmt -> ; .)
    {               reduce using rule 48 (stmt -> ; .)
    INC             reduce using rule 48 (stmt -> ; .)
    DEC             reduce using rule 48 (stmt -> ; .)
    INT             reduce using rule 48 (stmt -> ; .)
    FLOAT           reduce using rule 48 (stmt -> ; .)
    BOOLEAN         reduce using rule 48 (stmt -> ; .)
    ID              reduce using rule 48 (stmt -> ; .)
    THIS            reduce using rule 48 (stmt -> ; .)
    SUPER           reduce using rule 48 (stmt -> ; .)
    (               reduce using rule 48 (stmt -> ; .)
    NEW             reduce using rule 48 (stmt -> ; .)
    INT_CONST       reduce using rule 48 (stmt -> ; .)
    FLOAT_CONST     reduce using rule 48 (stmt -> ; .)
    STRING_CONST    reduce using rule 48 (stmt -> ; .)
    NULL            reduce using rule 48 (stmt -> ; .)
    TRUE            reduce using rule 48 (stmt -> ; .)
    FALSE           reduce using rule 48 (stmt -> ; .)
    ELSE            reduce using rule 48 (stmt -> ; .)


state 81

    (77) method_invocation -> field_access . ( has_arguments )
    (72) lhs -> field_access .

    (               shift and go to state 123
    =               reduce using rule 72 (lhs -> field_access .)
    INC             reduce using rule 72 (lhs -> field_access .)
    DEC             reduce using rule 72 (lhs -> field_access .)
    .               reduce using rule 72 (lhs -> field_access .)
    [               reduce using rule 72 (lhs -> field_access .)


state 82

    (41) stmt -> FOR . ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt

    (               shift and go to state 124


state 83

    (63) primary -> SUPER .

    .               reduce using rule 63 (primary -> SUPER .)
    [               reduce using rule 63 (primary -> SUPER .)
    +               reduce using rule 63 (primary -> SUPER .)
    -               reduce using rule 63 (primary -> SUPER .)
    *               reduce using rule 63 (primary -> SUPER .)
    /               reduce using rule 63 (primary -> SUPER .)
    AND             reduce using rule 63 (primary -> SUPER .)
    OR              reduce using rule 63 (primary -> SUPER .)
    EQL             reduce using rule 63 (primary -> SUPER .)
    UNEQL           reduce using rule 63 (primary -> SUPER .)
    <               reduce using rule 63 (primary -> SUPER .)
    >               reduce using rule 63 (primary -> SUPER .)
    LE              reduce using rule 63 (primary -> SUPER .)
    GE              reduce using rule 63 (primary -> SUPER .)
    ;               reduce using rule 63 (primary -> SUPER .)
    )               reduce using rule 63 (primary -> SUPER .)
    ]               reduce using rule 63 (primary -> SUPER .)
    ,               reduce using rule 63 (primary -> SUPER .)


state 84

    (36) stmts -> stmts stmt .

    }               reduce using rule 36 (stmts -> stmts stmt .)
    IF              reduce using rule 36 (stmts -> stmts stmt .)
    WHILE           reduce using rule 36 (stmts -> stmts stmt .)
    FOR             reduce using rule 36 (stmts -> stmts stmt .)
    RETURN          reduce using rule 36 (stmts -> stmts stmt .)
    BREAK           reduce using rule 36 (stmts -> stmts stmt .)
    CONTINUE        reduce using rule 36 (stmts -> stmts stmt .)
    ;               reduce using rule 36 (stmts -> stmts stmt .)
    {               reduce using rule 36 (stmts -> stmts stmt .)
    INC             reduce using rule 36 (stmts -> stmts stmt .)
    DEC             reduce using rule 36 (stmts -> stmts stmt .)
    INT             reduce using rule 36 (stmts -> stmts stmt .)
    FLOAT           reduce using rule 36 (stmts -> stmts stmt .)
    BOOLEAN         reduce using rule 36 (stmts -> stmts stmt .)
    ID              reduce using rule 36 (stmts -> stmts stmt .)
    THIS            reduce using rule 36 (stmts -> stmts stmt .)
    SUPER           reduce using rule 36 (stmts -> stmts stmt .)
    (               reduce using rule 36 (stmts -> stmts stmt .)
    NEW             reduce using rule 36 (stmts -> stmts stmt .)
    INT_CONST       reduce using rule 36 (stmts -> stmts stmt .)
    FLOAT_CONST     reduce using rule 36 (stmts -> stmts stmt .)
    STRING_CONST    reduce using rule 36 (stmts -> stmts stmt .)
    NULL            reduce using rule 36 (stmts -> stmts stmt .)
    TRUE            reduce using rule 36 (stmts -> stmts stmt .)
    FALSE           reduce using rule 36 (stmts -> stmts stmt .)


state 85

    (62) primary -> THIS .

    .               reduce using rule 62 (primary -> THIS .)
    [               reduce using rule 62 (primary -> THIS .)
    +               reduce using rule 62 (primary -> THIS .)
    -               reduce using rule 62 (primary -> THIS .)
    *               reduce using rule 62 (primary -> THIS .)
    /               reduce using rule 62 (primary -> THIS .)
    AND             reduce using rule 62 (primary -> THIS .)
    OR              reduce using rule 62 (primary -> THIS .)
    EQL             reduce using rule 62 (primary -> THIS .)
    UNEQL           reduce using rule 62 (primary -> THIS .)
    <               reduce using rule 62 (primary -> THIS .)
    >               reduce using rule 62 (primary -> THIS .)
    LE              reduce using rule 62 (primary -> THIS .)
    GE              reduce using rule 62 (primary -> THIS .)
    ;               reduce using rule 62 (primary -> THIS .)
    )               reduce using rule 62 (primary -> THIS .)
    ]               reduce using rule 62 (primary -> THIS .)
    ,               reduce using rule 62 (primary -> THIS .)


state 86

    (21) type -> ID .
    (75) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    (               reduce using rule 75 (field_access -> ID .)
    =               reduce using rule 75 (field_access -> ID .)
    INC             reduce using rule 75 (field_access -> ID .)
    DEC             reduce using rule 75 (field_access -> ID .)
    .               reduce using rule 75 (field_access -> ID .)
    [               reduce using rule 75 (field_access -> ID .)


state 87

    (59) literal -> TRUE .

    .               reduce using rule 59 (literal -> TRUE .)
    [               reduce using rule 59 (literal -> TRUE .)
    +               reduce using rule 59 (literal -> TRUE .)
    -               reduce using rule 59 (literal -> TRUE .)
    *               reduce using rule 59 (literal -> TRUE .)
    /               reduce using rule 59 (literal -> TRUE .)
    AND             reduce using rule 59 (literal -> TRUE .)
    OR              reduce using rule 59 (literal -> TRUE .)
    EQL             reduce using rule 59 (literal -> TRUE .)
    UNEQL           reduce using rule 59 (literal -> TRUE .)
    <               reduce using rule 59 (literal -> TRUE .)
    >               reduce using rule 59 (literal -> TRUE .)
    LE              reduce using rule 59 (literal -> TRUE .)
    GE              reduce using rule 59 (literal -> TRUE .)
    ,               reduce using rule 59 (literal -> TRUE .)
    )               reduce using rule 59 (literal -> TRUE .)
    ;               reduce using rule 59 (literal -> TRUE .)
    ]               reduce using rule 59 (literal -> TRUE .)


state 88

    (38) stmt -> IF . ( expr ) stmt
    (39) stmt -> IF . ( expr ) stmt ELSE stmt

    (               shift and go to state 125


state 89

    (60) literal -> FALSE .

    .               reduce using rule 60 (literal -> FALSE .)
    [               reduce using rule 60 (literal -> FALSE .)
    +               reduce using rule 60 (literal -> FALSE .)
    -               reduce using rule 60 (literal -> FALSE .)
    *               reduce using rule 60 (literal -> FALSE .)
    /               reduce using rule 60 (literal -> FALSE .)
    AND             reduce using rule 60 (literal -> FALSE .)
    OR              reduce using rule 60 (literal -> FALSE .)
    EQL             reduce using rule 60 (literal -> FALSE .)
    UNEQL           reduce using rule 60 (literal -> FALSE .)
    <               reduce using rule 60 (literal -> FALSE .)
    >               reduce using rule 60 (literal -> FALSE .)
    LE              reduce using rule 60 (literal -> FALSE .)
    GE              reduce using rule 60 (literal -> FALSE .)
    ,               reduce using rule 60 (literal -> FALSE .)
    )               reduce using rule 60 (literal -> FALSE .)
    ;               reduce using rule 60 (literal -> FALSE .)
    ]               reduce using rule 60 (literal -> FALSE .)


state 90

    (47) stmt -> var_decl .

    }               reduce using rule 47 (stmt -> var_decl .)
    IF              reduce using rule 47 (stmt -> var_decl .)
    WHILE           reduce using rule 47 (stmt -> var_decl .)
    FOR             reduce using rule 47 (stmt -> var_decl .)
    RETURN          reduce using rule 47 (stmt -> var_decl .)
    BREAK           reduce using rule 47 (stmt -> var_decl .)
    CONTINUE        reduce using rule 47 (stmt -> var_decl .)
    ;               reduce using rule 47 (stmt -> var_decl .)
    {               reduce using rule 47 (stmt -> var_decl .)
    INC             reduce using rule 47 (stmt -> var_decl .)
    DEC             reduce using rule 47 (stmt -> var_decl .)
    INT             reduce using rule 47 (stmt -> var_decl .)
    FLOAT           reduce using rule 47 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 47 (stmt -> var_decl .)
    ID              reduce using rule 47 (stmt -> var_decl .)
    THIS            reduce using rule 47 (stmt -> var_decl .)
    SUPER           reduce using rule 47 (stmt -> var_decl .)
    (               reduce using rule 47 (stmt -> var_decl .)
    NEW             reduce using rule 47 (stmt -> var_decl .)
    INT_CONST       reduce using rule 47 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 47 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 47 (stmt -> var_decl .)
    NULL            reduce using rule 47 (stmt -> var_decl .)
    TRUE            reduce using rule 47 (stmt -> var_decl .)
    FALSE           reduce using rule 47 (stmt -> var_decl .)
    ELSE            reduce using rule 47 (stmt -> var_decl .)


state 91

    (44) stmt -> BREAK . ;

    ;               shift and go to state 126


state 92

    (45) stmt -> CONTINUE . ;

    ;               shift and go to state 127


state 93

    (84) assign -> lhs . = expr
    (85) assign -> lhs . INC
    (87) assign -> lhs . DEC
    (66) primary -> lhs .

    =               shift and go to state 128
    INC             shift and go to state 130
    DEC             shift and go to state 129
    .               reduce using rule 66 (primary -> lhs .)
    [               reduce using rule 66 (primary -> lhs .)


state 94

    (35) block -> { stmts } .

    }               reduce using rule 35 (block -> { stmts } .)
    PUBLIC          reduce using rule 35 (block -> { stmts } .)
    PRIVATE         reduce using rule 35 (block -> { stmts } .)
    (               reduce using rule 35 (block -> { stmts } .)
    ID              reduce using rule 35 (block -> { stmts } .)
    INT             reduce using rule 35 (block -> { stmts } .)
    FLOAT           reduce using rule 35 (block -> { stmts } .)
    BOOLEAN         reduce using rule 35 (block -> { stmts } .)
    STATIC          reduce using rule 35 (block -> { stmts } .)
    IF              reduce using rule 35 (block -> { stmts } .)
    WHILE           reduce using rule 35 (block -> { stmts } .)
    FOR             reduce using rule 35 (block -> { stmts } .)
    RETURN          reduce using rule 35 (block -> { stmts } .)
    BREAK           reduce using rule 35 (block -> { stmts } .)
    CONTINUE        reduce using rule 35 (block -> { stmts } .)
    ;               reduce using rule 35 (block -> { stmts } .)
    {               reduce using rule 35 (block -> { stmts } .)
    INC             reduce using rule 35 (block -> { stmts } .)
    DEC             reduce using rule 35 (block -> { stmts } .)
    THIS            reduce using rule 35 (block -> { stmts } .)
    SUPER           reduce using rule 35 (block -> { stmts } .)
    NEW             reduce using rule 35 (block -> { stmts } .)
    INT_CONST       reduce using rule 35 (block -> { stmts } .)
    FLOAT_CONST     reduce using rule 35 (block -> { stmts } .)
    STRING_CONST    reduce using rule 35 (block -> { stmts } .)
    NULL            reduce using rule 35 (block -> { stmts } .)
    TRUE            reduce using rule 35 (block -> { stmts } .)
    FALSE           reduce using rule 35 (block -> { stmts } .)
    ELSE            reduce using rule 35 (block -> { stmts } .)


state 95

    (108) stmt_expr -> assign .

    ;               reduce using rule 108 (stmt_expr -> assign .)
    )               reduce using rule 108 (stmt_expr -> assign .)


state 96

    (46) stmt -> block .

    }               reduce using rule 46 (stmt -> block .)
    IF              reduce using rule 46 (stmt -> block .)
    WHILE           reduce using rule 46 (stmt -> block .)
    FOR             reduce using rule 46 (stmt -> block .)
    RETURN          reduce using rule 46 (stmt -> block .)
    BREAK           reduce using rule 46 (stmt -> block .)
    CONTINUE        reduce using rule 46 (stmt -> block .)
    ;               reduce using rule 46 (stmt -> block .)
    {               reduce using rule 46 (stmt -> block .)
    INC             reduce using rule 46 (stmt -> block .)
    DEC             reduce using rule 46 (stmt -> block .)
    INT             reduce using rule 46 (stmt -> block .)
    FLOAT           reduce using rule 46 (stmt -> block .)
    BOOLEAN         reduce using rule 46 (stmt -> block .)
    ID              reduce using rule 46 (stmt -> block .)
    THIS            reduce using rule 46 (stmt -> block .)
    SUPER           reduce using rule 46 (stmt -> block .)
    (               reduce using rule 46 (stmt -> block .)
    NEW             reduce using rule 46 (stmt -> block .)
    INT_CONST       reduce using rule 46 (stmt -> block .)
    FLOAT_CONST     reduce using rule 46 (stmt -> block .)
    STRING_CONST    reduce using rule 46 (stmt -> block .)
    NULL            reduce using rule 46 (stmt -> block .)
    TRUE            reduce using rule 46 (stmt -> block .)
    FALSE           reduce using rule 46 (stmt -> block .)
    ELSE            reduce using rule 46 (stmt -> block .)


state 97

    (86) assign -> INC . lhs
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (77) method_invocation -> . field_access ( has_arguments )

    ID              shift and go to state 115
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 113
    primary                        shift and go to state 66
    literal                        shift and go to state 78
    lhs                            shift and go to state 131
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72

state 98

    (27) method_decl -> modifier ( all_type ) ID ( ) block .

    }               reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    (               reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    ID              reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    INT             reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)
    STATIC          reduce using rule 27 (method_decl -> modifier ( all_type ) ID ( ) block .)


state 99

    (26) method_decl -> modifier ( all_type ) ID ( formals ) . block
    (35) block -> . { stmts }

    {               shift and go to state 53

    block                          shift and go to state 132

state 100

    (74) field_access -> primary . . ID

    ID              shift and go to state 133


state 101

    (76) array_access -> primary [ . expr ]
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 134
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 102

    (40) stmt -> WHILE ( . expr ) stmt
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 135
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 103

    (65) primary -> NEW ID . ( has_arguments )

    (               shift and go to state 136


state 104

    (80) expr -> new_array .
    (89) new_array -> new_array . [ ]

    +               reduce using rule 80 (expr -> new_array .)
    -               reduce using rule 80 (expr -> new_array .)
    *               reduce using rule 80 (expr -> new_array .)
    /               reduce using rule 80 (expr -> new_array .)
    AND             reduce using rule 80 (expr -> new_array .)
    OR              reduce using rule 80 (expr -> new_array .)
    EQL             reduce using rule 80 (expr -> new_array .)
    UNEQL           reduce using rule 80 (expr -> new_array .)
    <               reduce using rule 80 (expr -> new_array .)
    >               reduce using rule 80 (expr -> new_array .)
    LE              reduce using rule 80 (expr -> new_array .)
    GE              reduce using rule 80 (expr -> new_array .)
    ,               reduce using rule 80 (expr -> new_array .)
    )               reduce using rule 80 (expr -> new_array .)
    ]               reduce using rule 80 (expr -> new_array .)
    ;               reduce using rule 80 (expr -> new_array .)
    [               shift and go to state 137


state 105

    (78) expr -> primary .
    (74) field_access -> primary . . ID
    (76) array_access -> primary . [ expr ]

    +               reduce using rule 78 (expr -> primary .)
    -               reduce using rule 78 (expr -> primary .)
    *               reduce using rule 78 (expr -> primary .)
    /               reduce using rule 78 (expr -> primary .)
    AND             reduce using rule 78 (expr -> primary .)
    OR              reduce using rule 78 (expr -> primary .)
    EQL             reduce using rule 78 (expr -> primary .)
    UNEQL           reduce using rule 78 (expr -> primary .)
    <               reduce using rule 78 (expr -> primary .)
    >               reduce using rule 78 (expr -> primary .)
    LE              reduce using rule 78 (expr -> primary .)
    GE              reduce using rule 78 (expr -> primary .)
    ,               reduce using rule 78 (expr -> primary .)
    )               reduce using rule 78 (expr -> primary .)
    ]               reduce using rule 78 (expr -> primary .)
    ;               reduce using rule 78 (expr -> primary .)
    .               shift and go to state 100
    [               shift and go to state 101


state 106

    (83) expr -> unary_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 138
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 107

    (65) primary -> NEW . ID ( has_arguments )
    (92) new_array_temp -> NEW . type [ expr ]
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    ID              shift and go to state 140
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27

    type                           shift and go to state 139

state 108

    (107) unary_op -> ! .

    THIS            reduce using rule 107 (unary_op -> ! .)
    SUPER           reduce using rule 107 (unary_op -> ! .)
    (               reduce using rule 107 (unary_op -> ! .)
    NEW             reduce using rule 107 (unary_op -> ! .)
    INC             reduce using rule 107 (unary_op -> ! .)
    DEC             reduce using rule 107 (unary_op -> ! .)
    +               reduce using rule 107 (unary_op -> ! .)
    -               reduce using rule 107 (unary_op -> ! .)
    !               reduce using rule 107 (unary_op -> ! .)
    INT_CONST       reduce using rule 107 (unary_op -> ! .)
    FLOAT_CONST     reduce using rule 107 (unary_op -> ! .)
    STRING_CONST    reduce using rule 107 (unary_op -> ! .)
    NULL            reduce using rule 107 (unary_op -> ! .)
    TRUE            reduce using rule 107 (unary_op -> ! .)
    FALSE           reduce using rule 107 (unary_op -> ! .)
    ID              reduce using rule 107 (unary_op -> ! .)


state 109

    (105) unary_op -> + .

    THIS            reduce using rule 105 (unary_op -> + .)
    SUPER           reduce using rule 105 (unary_op -> + .)
    (               reduce using rule 105 (unary_op -> + .)
    NEW             reduce using rule 105 (unary_op -> + .)
    INC             reduce using rule 105 (unary_op -> + .)
    DEC             reduce using rule 105 (unary_op -> + .)
    +               reduce using rule 105 (unary_op -> + .)
    -               reduce using rule 105 (unary_op -> + .)
    !               reduce using rule 105 (unary_op -> + .)
    INT_CONST       reduce using rule 105 (unary_op -> + .)
    FLOAT_CONST     reduce using rule 105 (unary_op -> + .)
    STRING_CONST    reduce using rule 105 (unary_op -> + .)
    NULL            reduce using rule 105 (unary_op -> + .)
    TRUE            reduce using rule 105 (unary_op -> + .)
    FALSE           reduce using rule 105 (unary_op -> + .)
    ID              reduce using rule 105 (unary_op -> + .)


state 110

    (106) unary_op -> - .

    THIS            reduce using rule 106 (unary_op -> - .)
    SUPER           reduce using rule 106 (unary_op -> - .)
    (               reduce using rule 106 (unary_op -> - .)
    NEW             reduce using rule 106 (unary_op -> - .)
    INC             reduce using rule 106 (unary_op -> - .)
    DEC             reduce using rule 106 (unary_op -> - .)
    +               reduce using rule 106 (unary_op -> - .)
    -               reduce using rule 106 (unary_op -> - .)
    !               reduce using rule 106 (unary_op -> - .)
    INT_CONST       reduce using rule 106 (unary_op -> - .)
    FLOAT_CONST     reduce using rule 106 (unary_op -> - .)
    STRING_CONST    reduce using rule 106 (unary_op -> - .)
    NULL            reduce using rule 106 (unary_op -> - .)
    TRUE            reduce using rule 106 (unary_op -> - .)
    FALSE           reduce using rule 106 (unary_op -> - .)
    ID              reduce using rule 106 (unary_op -> - .)


state 111

    (67) primary -> method_invocation .

    .               reduce using rule 67 (primary -> method_invocation .)
    [               reduce using rule 67 (primary -> method_invocation .)
    +               reduce using rule 67 (primary -> method_invocation .)
    -               reduce using rule 67 (primary -> method_invocation .)
    *               reduce using rule 67 (primary -> method_invocation .)
    /               reduce using rule 67 (primary -> method_invocation .)
    AND             reduce using rule 67 (primary -> method_invocation .)
    OR              reduce using rule 67 (primary -> method_invocation .)
    EQL             reduce using rule 67 (primary -> method_invocation .)
    UNEQL           reduce using rule 67 (primary -> method_invocation .)
    <               reduce using rule 67 (primary -> method_invocation .)
    >               reduce using rule 67 (primary -> method_invocation .)
    LE              reduce using rule 67 (primary -> method_invocation .)
    GE              reduce using rule 67 (primary -> method_invocation .)
    ;               reduce using rule 67 (primary -> method_invocation .)
    )               reduce using rule 67 (primary -> method_invocation .)
    ]               reduce using rule 67 (primary -> method_invocation .)
    ,               reduce using rule 67 (primary -> method_invocation .)


state 112

    (52) has_expr -> empty .

    ;               reduce using rule 52 (has_expr -> empty .)


state 113

    (72) lhs -> field_access .
    (77) method_invocation -> field_access . ( has_arguments )

    =               reduce using rule 72 (lhs -> field_access .)
    INC             reduce using rule 72 (lhs -> field_access .)
    DEC             reduce using rule 72 (lhs -> field_access .)
    .               reduce using rule 72 (lhs -> field_access .)
    [               reduce using rule 72 (lhs -> field_access .)
    +               reduce using rule 72 (lhs -> field_access .)
    -               reduce using rule 72 (lhs -> field_access .)
    *               reduce using rule 72 (lhs -> field_access .)
    /               reduce using rule 72 (lhs -> field_access .)
    AND             reduce using rule 72 (lhs -> field_access .)
    OR              reduce using rule 72 (lhs -> field_access .)
    EQL             reduce using rule 72 (lhs -> field_access .)
    UNEQL           reduce using rule 72 (lhs -> field_access .)
    <               reduce using rule 72 (lhs -> field_access .)
    >               reduce using rule 72 (lhs -> field_access .)
    LE              reduce using rule 72 (lhs -> field_access .)
    GE              reduce using rule 72 (lhs -> field_access .)
    ,               reduce using rule 72 (lhs -> field_access .)
    )               reduce using rule 72 (lhs -> field_access .)
    ;               reduce using rule 72 (lhs -> field_access .)
    ]               reduce using rule 72 (lhs -> field_access .)
    (               shift and go to state 123


state 114

    (90) new_array -> new_array_temp .
    (91) new_array_temp -> new_array_temp . [ expr ]

  ! shift/reduce conflict for [ resolved as shift
    ]               reduce using rule 90 (new_array -> new_array_temp .)
    +               reduce using rule 90 (new_array -> new_array_temp .)
    -               reduce using rule 90 (new_array -> new_array_temp .)
    *               reduce using rule 90 (new_array -> new_array_temp .)
    /               reduce using rule 90 (new_array -> new_array_temp .)
    AND             reduce using rule 90 (new_array -> new_array_temp .)
    OR              reduce using rule 90 (new_array -> new_array_temp .)
    EQL             reduce using rule 90 (new_array -> new_array_temp .)
    UNEQL           reduce using rule 90 (new_array -> new_array_temp .)
    <               reduce using rule 90 (new_array -> new_array_temp .)
    >               reduce using rule 90 (new_array -> new_array_temp .)
    LE              reduce using rule 90 (new_array -> new_array_temp .)
    GE              reduce using rule 90 (new_array -> new_array_temp .)
    ;               reduce using rule 90 (new_array -> new_array_temp .)
    )               reduce using rule 90 (new_array -> new_array_temp .)
    ,               reduce using rule 90 (new_array -> new_array_temp .)
    [               shift and go to state 141

  ! [               [ reduce using rule 90 (new_array -> new_array_temp .) ]


state 115

    (75) field_access -> ID .

    (               reduce using rule 75 (field_access -> ID .)
    =               reduce using rule 75 (field_access -> ID .)
    INC             reduce using rule 75 (field_access -> ID .)
    DEC             reduce using rule 75 (field_access -> ID .)
    .               reduce using rule 75 (field_access -> ID .)
    [               reduce using rule 75 (field_access -> ID .)
    )               reduce using rule 75 (field_access -> ID .)
    +               reduce using rule 75 (field_access -> ID .)
    -               reduce using rule 75 (field_access -> ID .)
    *               reduce using rule 75 (field_access -> ID .)
    /               reduce using rule 75 (field_access -> ID .)
    AND             reduce using rule 75 (field_access -> ID .)
    OR              reduce using rule 75 (field_access -> ID .)
    EQL             reduce using rule 75 (field_access -> ID .)
    UNEQL           reduce using rule 75 (field_access -> ID .)
    <               reduce using rule 75 (field_access -> ID .)
    >               reduce using rule 75 (field_access -> ID .)
    LE              reduce using rule 75 (field_access -> ID .)
    GE              reduce using rule 75 (field_access -> ID .)
    ,               reduce using rule 75 (field_access -> ID .)
    ]               reduce using rule 75 (field_access -> ID .)
    ;               reduce using rule 75 (field_access -> ID .)


state 116

    (51) has_expr -> expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ;               reduce using rule 51 (has_expr -> expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 117

    (42) stmt -> RETURN has_expr . ;

    ;               shift and go to state 156


state 118

    (66) primary -> lhs .
    (84) assign -> lhs . = expr
    (85) assign -> lhs . INC
    (87) assign -> lhs . DEC

    .               reduce using rule 66 (primary -> lhs .)
    [               reduce using rule 66 (primary -> lhs .)
    +               reduce using rule 66 (primary -> lhs .)
    -               reduce using rule 66 (primary -> lhs .)
    *               reduce using rule 66 (primary -> lhs .)
    /               reduce using rule 66 (primary -> lhs .)
    AND             reduce using rule 66 (primary -> lhs .)
    OR              reduce using rule 66 (primary -> lhs .)
    EQL             reduce using rule 66 (primary -> lhs .)
    UNEQL           reduce using rule 66 (primary -> lhs .)
    <               reduce using rule 66 (primary -> lhs .)
    >               reduce using rule 66 (primary -> lhs .)
    LE              reduce using rule 66 (primary -> lhs .)
    GE              reduce using rule 66 (primary -> lhs .)
    ;               reduce using rule 66 (primary -> lhs .)
    )               reduce using rule 66 (primary -> lhs .)
    ]               reduce using rule 66 (primary -> lhs .)
    ,               reduce using rule 66 (primary -> lhs .)
    =               shift and go to state 128
    INC             shift and go to state 130
    DEC             shift and go to state 129


state 119

    (79) expr -> assign .

    +               reduce using rule 79 (expr -> assign .)
    -               reduce using rule 79 (expr -> assign .)
    *               reduce using rule 79 (expr -> assign .)
    /               reduce using rule 79 (expr -> assign .)
    AND             reduce using rule 79 (expr -> assign .)
    OR              reduce using rule 79 (expr -> assign .)
    EQL             reduce using rule 79 (expr -> assign .)
    UNEQL           reduce using rule 79 (expr -> assign .)
    <               reduce using rule 79 (expr -> assign .)
    >               reduce using rule 79 (expr -> assign .)
    LE              reduce using rule 79 (expr -> assign .)
    GE              reduce using rule 79 (expr -> assign .)
    ,               reduce using rule 79 (expr -> assign .)
    )               reduce using rule 79 (expr -> assign .)
    ]               reduce using rule 79 (expr -> assign .)
    ;               reduce using rule 79 (expr -> assign .)


state 120

    (88) assign -> DEC lhs .
    (66) primary -> lhs .

    ;               reduce using rule 88 (assign -> DEC lhs .)
    +               reduce using rule 88 (assign -> DEC lhs .)
    -               reduce using rule 88 (assign -> DEC lhs .)
    *               reduce using rule 88 (assign -> DEC lhs .)
    /               reduce using rule 88 (assign -> DEC lhs .)
    AND             reduce using rule 88 (assign -> DEC lhs .)
    OR              reduce using rule 88 (assign -> DEC lhs .)
    EQL             reduce using rule 88 (assign -> DEC lhs .)
    UNEQL           reduce using rule 88 (assign -> DEC lhs .)
    <               reduce using rule 88 (assign -> DEC lhs .)
    >               reduce using rule 88 (assign -> DEC lhs .)
    LE              reduce using rule 88 (assign -> DEC lhs .)
    GE              reduce using rule 88 (assign -> DEC lhs .)
    )               reduce using rule 88 (assign -> DEC lhs .)
    ]               reduce using rule 88 (assign -> DEC lhs .)
    ,               reduce using rule 88 (assign -> DEC lhs .)
    .               reduce using rule 66 (primary -> lhs .)
    [               reduce using rule 66 (primary -> lhs .)


state 121

    (64) primary -> ( expr . )
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    )               shift and go to state 157
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 122

    (43) stmt -> stmt_expr ; .

    }               reduce using rule 43 (stmt -> stmt_expr ; .)
    IF              reduce using rule 43 (stmt -> stmt_expr ; .)
    WHILE           reduce using rule 43 (stmt -> stmt_expr ; .)
    FOR             reduce using rule 43 (stmt -> stmt_expr ; .)
    RETURN          reduce using rule 43 (stmt -> stmt_expr ; .)
    BREAK           reduce using rule 43 (stmt -> stmt_expr ; .)
    CONTINUE        reduce using rule 43 (stmt -> stmt_expr ; .)
    ;               reduce using rule 43 (stmt -> stmt_expr ; .)
    {               reduce using rule 43 (stmt -> stmt_expr ; .)
    INC             reduce using rule 43 (stmt -> stmt_expr ; .)
    DEC             reduce using rule 43 (stmt -> stmt_expr ; .)
    INT             reduce using rule 43 (stmt -> stmt_expr ; .)
    FLOAT           reduce using rule 43 (stmt -> stmt_expr ; .)
    BOOLEAN         reduce using rule 43 (stmt -> stmt_expr ; .)
    ID              reduce using rule 43 (stmt -> stmt_expr ; .)
    THIS            reduce using rule 43 (stmt -> stmt_expr ; .)
    SUPER           reduce using rule 43 (stmt -> stmt_expr ; .)
    (               reduce using rule 43 (stmt -> stmt_expr ; .)
    NEW             reduce using rule 43 (stmt -> stmt_expr ; .)
    INT_CONST       reduce using rule 43 (stmt -> stmt_expr ; .)
    FLOAT_CONST     reduce using rule 43 (stmt -> stmt_expr ; .)
    STRING_CONST    reduce using rule 43 (stmt -> stmt_expr ; .)
    NULL            reduce using rule 43 (stmt -> stmt_expr ; .)
    TRUE            reduce using rule 43 (stmt -> stmt_expr ; .)
    FALSE           reduce using rule 43 (stmt -> stmt_expr ; .)
    ELSE            reduce using rule 43 (stmt -> stmt_expr ; .)


state 123

    (77) method_invocation -> field_access ( . has_arguments )
    (68) has_arguments -> . arguments
    (69) has_arguments -> . empty
    (70) arguments -> . arguments , expr
    (71) arguments -> . expr
    (110) empty -> .
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    )               reduce using rule 110 (empty -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    field_access                   shift and go to state 113
    new_array_temp                 shift and go to state 114
    new_array                      shift and go to state 104
    has_arguments                  shift and go to state 158
    expr                           shift and go to state 161
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    arguments                      shift and go to state 159
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119
    empty                          shift and go to state 160
    unary_op                       shift and go to state 106

state 124

    (41) stmt -> FOR ( . has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (49) has_stmt_expr -> . stmt_expr
    (50) has_stmt_expr -> . empty
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (110) empty -> .
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    ;               reduce using rule 110 (empty -> .)
    INC             shift and go to state 97
    DEC             shift and go to state 71
    ID              shift and go to state 115
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    has_stmt_expr                  shift and go to state 162
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt_expr                      shift and go to state 163
    lhs                            shift and go to state 93
    method_invocation              shift and go to state 79
    array_access                   shift and go to state 72
    assign                         shift and go to state 95
    empty                          shift and go to state 164

state 125

    (38) stmt -> IF ( . expr ) stmt
    (39) stmt -> IF ( . expr ) stmt ELSE stmt
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 165
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 126

    (44) stmt -> BREAK ; .

    }               reduce using rule 44 (stmt -> BREAK ; .)
    IF              reduce using rule 44 (stmt -> BREAK ; .)
    WHILE           reduce using rule 44 (stmt -> BREAK ; .)
    FOR             reduce using rule 44 (stmt -> BREAK ; .)
    RETURN          reduce using rule 44 (stmt -> BREAK ; .)
    BREAK           reduce using rule 44 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 44 (stmt -> BREAK ; .)
    ;               reduce using rule 44 (stmt -> BREAK ; .)
    {               reduce using rule 44 (stmt -> BREAK ; .)
    INC             reduce using rule 44 (stmt -> BREAK ; .)
    DEC             reduce using rule 44 (stmt -> BREAK ; .)
    INT             reduce using rule 44 (stmt -> BREAK ; .)
    FLOAT           reduce using rule 44 (stmt -> BREAK ; .)
    BOOLEAN         reduce using rule 44 (stmt -> BREAK ; .)
    ID              reduce using rule 44 (stmt -> BREAK ; .)
    THIS            reduce using rule 44 (stmt -> BREAK ; .)
    SUPER           reduce using rule 44 (stmt -> BREAK ; .)
    (               reduce using rule 44 (stmt -> BREAK ; .)
    NEW             reduce using rule 44 (stmt -> BREAK ; .)
    INT_CONST       reduce using rule 44 (stmt -> BREAK ; .)
    FLOAT_CONST     reduce using rule 44 (stmt -> BREAK ; .)
    STRING_CONST    reduce using rule 44 (stmt -> BREAK ; .)
    NULL            reduce using rule 44 (stmt -> BREAK ; .)
    TRUE            reduce using rule 44 (stmt -> BREAK ; .)
    FALSE           reduce using rule 44 (stmt -> BREAK ; .)
    ELSE            reduce using rule 44 (stmt -> BREAK ; .)


state 127

    (45) stmt -> CONTINUE ; .

    }               reduce using rule 45 (stmt -> CONTINUE ; .)
    IF              reduce using rule 45 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 45 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 45 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 45 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 45 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 45 (stmt -> CONTINUE ; .)
    ;               reduce using rule 45 (stmt -> CONTINUE ; .)
    {               reduce using rule 45 (stmt -> CONTINUE ; .)
    INC             reduce using rule 45 (stmt -> CONTINUE ; .)
    DEC             reduce using rule 45 (stmt -> CONTINUE ; .)
    INT             reduce using rule 45 (stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 45 (stmt -> CONTINUE ; .)
    BOOLEAN         reduce using rule 45 (stmt -> CONTINUE ; .)
    ID              reduce using rule 45 (stmt -> CONTINUE ; .)
    THIS            reduce using rule 45 (stmt -> CONTINUE ; .)
    SUPER           reduce using rule 45 (stmt -> CONTINUE ; .)
    (               reduce using rule 45 (stmt -> CONTINUE ; .)
    NEW             reduce using rule 45 (stmt -> CONTINUE ; .)
    INT_CONST       reduce using rule 45 (stmt -> CONTINUE ; .)
    FLOAT_CONST     reduce using rule 45 (stmt -> CONTINUE ; .)
    STRING_CONST    reduce using rule 45 (stmt -> CONTINUE ; .)
    NULL            reduce using rule 45 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 45 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 45 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 45 (stmt -> CONTINUE ; .)


state 128

    (84) assign -> lhs = . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 166
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 129

    (87) assign -> lhs DEC .

    ;               reduce using rule 87 (assign -> lhs DEC .)
    +               reduce using rule 87 (assign -> lhs DEC .)
    -               reduce using rule 87 (assign -> lhs DEC .)
    *               reduce using rule 87 (assign -> lhs DEC .)
    /               reduce using rule 87 (assign -> lhs DEC .)
    AND             reduce using rule 87 (assign -> lhs DEC .)
    OR              reduce using rule 87 (assign -> lhs DEC .)
    EQL             reduce using rule 87 (assign -> lhs DEC .)
    UNEQL           reduce using rule 87 (assign -> lhs DEC .)
    <               reduce using rule 87 (assign -> lhs DEC .)
    >               reduce using rule 87 (assign -> lhs DEC .)
    LE              reduce using rule 87 (assign -> lhs DEC .)
    GE              reduce using rule 87 (assign -> lhs DEC .)
    )               reduce using rule 87 (assign -> lhs DEC .)
    ]               reduce using rule 87 (assign -> lhs DEC .)
    ,               reduce using rule 87 (assign -> lhs DEC .)


state 130

    (85) assign -> lhs INC .

    ;               reduce using rule 85 (assign -> lhs INC .)
    +               reduce using rule 85 (assign -> lhs INC .)
    -               reduce using rule 85 (assign -> lhs INC .)
    *               reduce using rule 85 (assign -> lhs INC .)
    /               reduce using rule 85 (assign -> lhs INC .)
    AND             reduce using rule 85 (assign -> lhs INC .)
    OR              reduce using rule 85 (assign -> lhs INC .)
    EQL             reduce using rule 85 (assign -> lhs INC .)
    UNEQL           reduce using rule 85 (assign -> lhs INC .)
    <               reduce using rule 85 (assign -> lhs INC .)
    >               reduce using rule 85 (assign -> lhs INC .)
    LE              reduce using rule 85 (assign -> lhs INC .)
    GE              reduce using rule 85 (assign -> lhs INC .)
    )               reduce using rule 85 (assign -> lhs INC .)
    ]               reduce using rule 85 (assign -> lhs INC .)
    ,               reduce using rule 85 (assign -> lhs INC .)


state 131

    (86) assign -> INC lhs .
    (66) primary -> lhs .

    ;               reduce using rule 86 (assign -> INC lhs .)
    +               reduce using rule 86 (assign -> INC lhs .)
    -               reduce using rule 86 (assign -> INC lhs .)
    *               reduce using rule 86 (assign -> INC lhs .)
    /               reduce using rule 86 (assign -> INC lhs .)
    AND             reduce using rule 86 (assign -> INC lhs .)
    OR              reduce using rule 86 (assign -> INC lhs .)
    EQL             reduce using rule 86 (assign -> INC lhs .)
    UNEQL           reduce using rule 86 (assign -> INC lhs .)
    <               reduce using rule 86 (assign -> INC lhs .)
    >               reduce using rule 86 (assign -> INC lhs .)
    LE              reduce using rule 86 (assign -> INC lhs .)
    GE              reduce using rule 86 (assign -> INC lhs .)
    )               reduce using rule 86 (assign -> INC lhs .)
    ]               reduce using rule 86 (assign -> INC lhs .)
    ,               reduce using rule 86 (assign -> INC lhs .)
    .               reduce using rule 66 (primary -> lhs .)
    [               reduce using rule 66 (primary -> lhs .)


state 132

    (26) method_decl -> modifier ( all_type ) ID ( formals ) block .

    }               reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    (               reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    ID              reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    INT             reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)
    STATIC          reduce using rule 26 (method_decl -> modifier ( all_type ) ID ( formals ) block .)


state 133

    (74) field_access -> primary . ID .

    (               reduce using rule 74 (field_access -> primary . ID .)
    =               reduce using rule 74 (field_access -> primary . ID .)
    INC             reduce using rule 74 (field_access -> primary . ID .)
    DEC             reduce using rule 74 (field_access -> primary . ID .)
    .               reduce using rule 74 (field_access -> primary . ID .)
    [               reduce using rule 74 (field_access -> primary . ID .)
    )               reduce using rule 74 (field_access -> primary . ID .)
    +               reduce using rule 74 (field_access -> primary . ID .)
    -               reduce using rule 74 (field_access -> primary . ID .)
    *               reduce using rule 74 (field_access -> primary . ID .)
    /               reduce using rule 74 (field_access -> primary . ID .)
    AND             reduce using rule 74 (field_access -> primary . ID .)
    OR              reduce using rule 74 (field_access -> primary . ID .)
    EQL             reduce using rule 74 (field_access -> primary . ID .)
    UNEQL           reduce using rule 74 (field_access -> primary . ID .)
    <               reduce using rule 74 (field_access -> primary . ID .)
    >               reduce using rule 74 (field_access -> primary . ID .)
    LE              reduce using rule 74 (field_access -> primary . ID .)
    GE              reduce using rule 74 (field_access -> primary . ID .)
    ,               reduce using rule 74 (field_access -> primary . ID .)
    ]               reduce using rule 74 (field_access -> primary . ID .)
    ;               reduce using rule 74 (field_access -> primary . ID .)


state 134

    (76) array_access -> primary [ expr . ]
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ]               shift and go to state 167
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 135

    (40) stmt -> WHILE ( expr . ) stmt
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    )               shift and go to state 168
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 136

    (65) primary -> NEW ID ( . has_arguments )
    (68) has_arguments -> . arguments
    (69) has_arguments -> . empty
    (70) arguments -> . arguments , expr
    (71) arguments -> . expr
    (110) empty -> .
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    )               reduce using rule 110 (empty -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    has_arguments                  shift and go to state 169
    expr                           shift and go to state 161
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    arguments                      shift and go to state 159
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119
    empty                          shift and go to state 160
    unary_op                       shift and go to state 106

state 137

    (89) new_array -> new_array [ . ]

    ]               shift and go to state 170


state 138

    (83) expr -> unary_op expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    ,               reduce using rule 83 (expr -> unary_op expr .)
    )               reduce using rule 83 (expr -> unary_op expr .)
    ]               reduce using rule 83 (expr -> unary_op expr .)
    ;               reduce using rule 83 (expr -> unary_op expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

  ! +               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! -               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! *               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! /               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! AND             [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! OR              [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! EQL             [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! UNEQL           [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! <               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! >               [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! LE              [ reduce using rule 83 (expr -> unary_op expr .) ]
  ! GE              [ reduce using rule 83 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 139

    (92) new_array_temp -> NEW type . [ expr ]

    [               shift and go to state 171


state 140

    (65) primary -> NEW ID . ( has_arguments )
    (21) type -> ID .

    (               shift and go to state 136
    [               reduce using rule 21 (type -> ID .)


state 141

    (91) new_array_temp -> new_array_temp [ . expr ]
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 172
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 142

    (81) expr -> expr arith_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 173
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 143

    (97) bool_op -> AND .

    THIS            reduce using rule 97 (bool_op -> AND .)
    SUPER           reduce using rule 97 (bool_op -> AND .)
    (               reduce using rule 97 (bool_op -> AND .)
    NEW             reduce using rule 97 (bool_op -> AND .)
    INC             reduce using rule 97 (bool_op -> AND .)
    DEC             reduce using rule 97 (bool_op -> AND .)
    +               reduce using rule 97 (bool_op -> AND .)
    -               reduce using rule 97 (bool_op -> AND .)
    !               reduce using rule 97 (bool_op -> AND .)
    INT_CONST       reduce using rule 97 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 97 (bool_op -> AND .)
    STRING_CONST    reduce using rule 97 (bool_op -> AND .)
    NULL            reduce using rule 97 (bool_op -> AND .)
    TRUE            reduce using rule 97 (bool_op -> AND .)
    FALSE           reduce using rule 97 (bool_op -> AND .)
    ID              reduce using rule 97 (bool_op -> AND .)


state 144

    (103) bool_op -> LE .

    THIS            reduce using rule 103 (bool_op -> LE .)
    SUPER           reduce using rule 103 (bool_op -> LE .)
    (               reduce using rule 103 (bool_op -> LE .)
    NEW             reduce using rule 103 (bool_op -> LE .)
    INC             reduce using rule 103 (bool_op -> LE .)
    DEC             reduce using rule 103 (bool_op -> LE .)
    +               reduce using rule 103 (bool_op -> LE .)
    -               reduce using rule 103 (bool_op -> LE .)
    !               reduce using rule 103 (bool_op -> LE .)
    INT_CONST       reduce using rule 103 (bool_op -> LE .)
    FLOAT_CONST     reduce using rule 103 (bool_op -> LE .)
    STRING_CONST    reduce using rule 103 (bool_op -> LE .)
    NULL            reduce using rule 103 (bool_op -> LE .)
    TRUE            reduce using rule 103 (bool_op -> LE .)
    FALSE           reduce using rule 103 (bool_op -> LE .)
    ID              reduce using rule 103 (bool_op -> LE .)


state 145

    (93) arith_op -> + .

    THIS            reduce using rule 93 (arith_op -> + .)
    SUPER           reduce using rule 93 (arith_op -> + .)
    (               reduce using rule 93 (arith_op -> + .)
    NEW             reduce using rule 93 (arith_op -> + .)
    INC             reduce using rule 93 (arith_op -> + .)
    DEC             reduce using rule 93 (arith_op -> + .)
    +               reduce using rule 93 (arith_op -> + .)
    -               reduce using rule 93 (arith_op -> + .)
    !               reduce using rule 93 (arith_op -> + .)
    INT_CONST       reduce using rule 93 (arith_op -> + .)
    FLOAT_CONST     reduce using rule 93 (arith_op -> + .)
    STRING_CONST    reduce using rule 93 (arith_op -> + .)
    NULL            reduce using rule 93 (arith_op -> + .)
    TRUE            reduce using rule 93 (arith_op -> + .)
    FALSE           reduce using rule 93 (arith_op -> + .)
    ID              reduce using rule 93 (arith_op -> + .)


state 146

    (95) arith_op -> * .

    THIS            reduce using rule 95 (arith_op -> * .)
    SUPER           reduce using rule 95 (arith_op -> * .)
    (               reduce using rule 95 (arith_op -> * .)
    NEW             reduce using rule 95 (arith_op -> * .)
    INC             reduce using rule 95 (arith_op -> * .)
    DEC             reduce using rule 95 (arith_op -> * .)
    +               reduce using rule 95 (arith_op -> * .)
    -               reduce using rule 95 (arith_op -> * .)
    !               reduce using rule 95 (arith_op -> * .)
    INT_CONST       reduce using rule 95 (arith_op -> * .)
    FLOAT_CONST     reduce using rule 95 (arith_op -> * .)
    STRING_CONST    reduce using rule 95 (arith_op -> * .)
    NULL            reduce using rule 95 (arith_op -> * .)
    TRUE            reduce using rule 95 (arith_op -> * .)
    FALSE           reduce using rule 95 (arith_op -> * .)
    ID              reduce using rule 95 (arith_op -> * .)


state 147

    (94) arith_op -> - .

    THIS            reduce using rule 94 (arith_op -> - .)
    SUPER           reduce using rule 94 (arith_op -> - .)
    (               reduce using rule 94 (arith_op -> - .)
    NEW             reduce using rule 94 (arith_op -> - .)
    INC             reduce using rule 94 (arith_op -> - .)
    DEC             reduce using rule 94 (arith_op -> - .)
    +               reduce using rule 94 (arith_op -> - .)
    -               reduce using rule 94 (arith_op -> - .)
    !               reduce using rule 94 (arith_op -> - .)
    INT_CONST       reduce using rule 94 (arith_op -> - .)
    FLOAT_CONST     reduce using rule 94 (arith_op -> - .)
    STRING_CONST    reduce using rule 94 (arith_op -> - .)
    NULL            reduce using rule 94 (arith_op -> - .)
    TRUE            reduce using rule 94 (arith_op -> - .)
    FALSE           reduce using rule 94 (arith_op -> - .)
    ID              reduce using rule 94 (arith_op -> - .)


state 148

    (96) arith_op -> / .

    THIS            reduce using rule 96 (arith_op -> / .)
    SUPER           reduce using rule 96 (arith_op -> / .)
    (               reduce using rule 96 (arith_op -> / .)
    NEW             reduce using rule 96 (arith_op -> / .)
    INC             reduce using rule 96 (arith_op -> / .)
    DEC             reduce using rule 96 (arith_op -> / .)
    +               reduce using rule 96 (arith_op -> / .)
    -               reduce using rule 96 (arith_op -> / .)
    !               reduce using rule 96 (arith_op -> / .)
    INT_CONST       reduce using rule 96 (arith_op -> / .)
    FLOAT_CONST     reduce using rule 96 (arith_op -> / .)
    STRING_CONST    reduce using rule 96 (arith_op -> / .)
    NULL            reduce using rule 96 (arith_op -> / .)
    TRUE            reduce using rule 96 (arith_op -> / .)
    FALSE           reduce using rule 96 (arith_op -> / .)
    ID              reduce using rule 96 (arith_op -> / .)


state 149

    (101) bool_op -> < .

    THIS            reduce using rule 101 (bool_op -> < .)
    SUPER           reduce using rule 101 (bool_op -> < .)
    (               reduce using rule 101 (bool_op -> < .)
    NEW             reduce using rule 101 (bool_op -> < .)
    INC             reduce using rule 101 (bool_op -> < .)
    DEC             reduce using rule 101 (bool_op -> < .)
    +               reduce using rule 101 (bool_op -> < .)
    -               reduce using rule 101 (bool_op -> < .)
    !               reduce using rule 101 (bool_op -> < .)
    INT_CONST       reduce using rule 101 (bool_op -> < .)
    FLOAT_CONST     reduce using rule 101 (bool_op -> < .)
    STRING_CONST    reduce using rule 101 (bool_op -> < .)
    NULL            reduce using rule 101 (bool_op -> < .)
    TRUE            reduce using rule 101 (bool_op -> < .)
    FALSE           reduce using rule 101 (bool_op -> < .)
    ID              reduce using rule 101 (bool_op -> < .)


state 150

    (100) bool_op -> UNEQL .

    THIS            reduce using rule 100 (bool_op -> UNEQL .)
    SUPER           reduce using rule 100 (bool_op -> UNEQL .)
    (               reduce using rule 100 (bool_op -> UNEQL .)
    NEW             reduce using rule 100 (bool_op -> UNEQL .)
    INC             reduce using rule 100 (bool_op -> UNEQL .)
    DEC             reduce using rule 100 (bool_op -> UNEQL .)
    +               reduce using rule 100 (bool_op -> UNEQL .)
    -               reduce using rule 100 (bool_op -> UNEQL .)
    !               reduce using rule 100 (bool_op -> UNEQL .)
    INT_CONST       reduce using rule 100 (bool_op -> UNEQL .)
    FLOAT_CONST     reduce using rule 100 (bool_op -> UNEQL .)
    STRING_CONST    reduce using rule 100 (bool_op -> UNEQL .)
    NULL            reduce using rule 100 (bool_op -> UNEQL .)
    TRUE            reduce using rule 100 (bool_op -> UNEQL .)
    FALSE           reduce using rule 100 (bool_op -> UNEQL .)
    ID              reduce using rule 100 (bool_op -> UNEQL .)


state 151

    (82) expr -> expr bool_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 174
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119

state 152

    (104) bool_op -> GE .

    THIS            reduce using rule 104 (bool_op -> GE .)
    SUPER           reduce using rule 104 (bool_op -> GE .)
    (               reduce using rule 104 (bool_op -> GE .)
    NEW             reduce using rule 104 (bool_op -> GE .)
    INC             reduce using rule 104 (bool_op -> GE .)
    DEC             reduce using rule 104 (bool_op -> GE .)
    +               reduce using rule 104 (bool_op -> GE .)
    -               reduce using rule 104 (bool_op -> GE .)
    !               reduce using rule 104 (bool_op -> GE .)
    INT_CONST       reduce using rule 104 (bool_op -> GE .)
    FLOAT_CONST     reduce using rule 104 (bool_op -> GE .)
    STRING_CONST    reduce using rule 104 (bool_op -> GE .)
    NULL            reduce using rule 104 (bool_op -> GE .)
    TRUE            reduce using rule 104 (bool_op -> GE .)
    FALSE           reduce using rule 104 (bool_op -> GE .)
    ID              reduce using rule 104 (bool_op -> GE .)


state 153

    (99) bool_op -> EQL .

    THIS            reduce using rule 99 (bool_op -> EQL .)
    SUPER           reduce using rule 99 (bool_op -> EQL .)
    (               reduce using rule 99 (bool_op -> EQL .)
    NEW             reduce using rule 99 (bool_op -> EQL .)
    INC             reduce using rule 99 (bool_op -> EQL .)
    DEC             reduce using rule 99 (bool_op -> EQL .)
    +               reduce using rule 99 (bool_op -> EQL .)
    -               reduce using rule 99 (bool_op -> EQL .)
    !               reduce using rule 99 (bool_op -> EQL .)
    INT_CONST       reduce using rule 99 (bool_op -> EQL .)
    FLOAT_CONST     reduce using rule 99 (bool_op -> EQL .)
    STRING_CONST    reduce using rule 99 (bool_op -> EQL .)
    NULL            reduce using rule 99 (bool_op -> EQL .)
    TRUE            reduce using rule 99 (bool_op -> EQL .)
    FALSE           reduce using rule 99 (bool_op -> EQL .)
    ID              reduce using rule 99 (bool_op -> EQL .)


state 154

    (98) bool_op -> OR .

    THIS            reduce using rule 98 (bool_op -> OR .)
    SUPER           reduce using rule 98 (bool_op -> OR .)
    (               reduce using rule 98 (bool_op -> OR .)
    NEW             reduce using rule 98 (bool_op -> OR .)
    INC             reduce using rule 98 (bool_op -> OR .)
    DEC             reduce using rule 98 (bool_op -> OR .)
    +               reduce using rule 98 (bool_op -> OR .)
    -               reduce using rule 98 (bool_op -> OR .)
    !               reduce using rule 98 (bool_op -> OR .)
    INT_CONST       reduce using rule 98 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 98 (bool_op -> OR .)
    STRING_CONST    reduce using rule 98 (bool_op -> OR .)
    NULL            reduce using rule 98 (bool_op -> OR .)
    TRUE            reduce using rule 98 (bool_op -> OR .)
    FALSE           reduce using rule 98 (bool_op -> OR .)
    ID              reduce using rule 98 (bool_op -> OR .)


state 155

    (102) bool_op -> > .

    THIS            reduce using rule 102 (bool_op -> > .)
    SUPER           reduce using rule 102 (bool_op -> > .)
    (               reduce using rule 102 (bool_op -> > .)
    NEW             reduce using rule 102 (bool_op -> > .)
    INC             reduce using rule 102 (bool_op -> > .)
    DEC             reduce using rule 102 (bool_op -> > .)
    +               reduce using rule 102 (bool_op -> > .)
    -               reduce using rule 102 (bool_op -> > .)
    !               reduce using rule 102 (bool_op -> > .)
    INT_CONST       reduce using rule 102 (bool_op -> > .)
    FLOAT_CONST     reduce using rule 102 (bool_op -> > .)
    STRING_CONST    reduce using rule 102 (bool_op -> > .)
    NULL            reduce using rule 102 (bool_op -> > .)
    TRUE            reduce using rule 102 (bool_op -> > .)
    FALSE           reduce using rule 102 (bool_op -> > .)
    ID              reduce using rule 102 (bool_op -> > .)


state 156

    (42) stmt -> RETURN has_expr ; .

    }               reduce using rule 42 (stmt -> RETURN has_expr ; .)
    IF              reduce using rule 42 (stmt -> RETURN has_expr ; .)
    WHILE           reduce using rule 42 (stmt -> RETURN has_expr ; .)
    FOR             reduce using rule 42 (stmt -> RETURN has_expr ; .)
    RETURN          reduce using rule 42 (stmt -> RETURN has_expr ; .)
    BREAK           reduce using rule 42 (stmt -> RETURN has_expr ; .)
    CONTINUE        reduce using rule 42 (stmt -> RETURN has_expr ; .)
    ;               reduce using rule 42 (stmt -> RETURN has_expr ; .)
    {               reduce using rule 42 (stmt -> RETURN has_expr ; .)
    INC             reduce using rule 42 (stmt -> RETURN has_expr ; .)
    DEC             reduce using rule 42 (stmt -> RETURN has_expr ; .)
    INT             reduce using rule 42 (stmt -> RETURN has_expr ; .)
    FLOAT           reduce using rule 42 (stmt -> RETURN has_expr ; .)
    BOOLEAN         reduce using rule 42 (stmt -> RETURN has_expr ; .)
    ID              reduce using rule 42 (stmt -> RETURN has_expr ; .)
    THIS            reduce using rule 42 (stmt -> RETURN has_expr ; .)
    SUPER           reduce using rule 42 (stmt -> RETURN has_expr ; .)
    (               reduce using rule 42 (stmt -> RETURN has_expr ; .)
    NEW             reduce using rule 42 (stmt -> RETURN has_expr ; .)
    INT_CONST       reduce using rule 42 (stmt -> RETURN has_expr ; .)
    FLOAT_CONST     reduce using rule 42 (stmt -> RETURN has_expr ; .)
    STRING_CONST    reduce using rule 42 (stmt -> RETURN has_expr ; .)
    NULL            reduce using rule 42 (stmt -> RETURN has_expr ; .)
    TRUE            reduce using rule 42 (stmt -> RETURN has_expr ; .)
    FALSE           reduce using rule 42 (stmt -> RETURN has_expr ; .)
    ELSE            reduce using rule 42 (stmt -> RETURN has_expr ; .)


state 157

    (64) primary -> ( expr ) .

    .               reduce using rule 64 (primary -> ( expr ) .)
    [               reduce using rule 64 (primary -> ( expr ) .)
    +               reduce using rule 64 (primary -> ( expr ) .)
    -               reduce using rule 64 (primary -> ( expr ) .)
    *               reduce using rule 64 (primary -> ( expr ) .)
    /               reduce using rule 64 (primary -> ( expr ) .)
    AND             reduce using rule 64 (primary -> ( expr ) .)
    OR              reduce using rule 64 (primary -> ( expr ) .)
    EQL             reduce using rule 64 (primary -> ( expr ) .)
    UNEQL           reduce using rule 64 (primary -> ( expr ) .)
    <               reduce using rule 64 (primary -> ( expr ) .)
    >               reduce using rule 64 (primary -> ( expr ) .)
    LE              reduce using rule 64 (primary -> ( expr ) .)
    GE              reduce using rule 64 (primary -> ( expr ) .)
    ;               reduce using rule 64 (primary -> ( expr ) .)
    )               reduce using rule 64 (primary -> ( expr ) .)
    ]               reduce using rule 64 (primary -> ( expr ) .)
    ,               reduce using rule 64 (primary -> ( expr ) .)


state 158

    (77) method_invocation -> field_access ( has_arguments . )

    )               shift and go to state 175


state 159

    (68) has_arguments -> arguments .
    (70) arguments -> arguments . , expr

    )               reduce using rule 68 (has_arguments -> arguments .)
    ,               shift and go to state 176


state 160

    (69) has_arguments -> empty .

    )               reduce using rule 69 (has_arguments -> empty .)


state 161

    (71) arguments -> expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ,               reduce using rule 71 (arguments -> expr .)
    )               reduce using rule 71 (arguments -> expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 162

    (41) stmt -> FOR ( has_stmt_expr . ; has_expr ; has_stmt_expr ) stmt

    ;               shift and go to state 177


state 163

    (49) has_stmt_expr -> stmt_expr .

    )               reduce using rule 49 (has_stmt_expr -> stmt_expr .)
    ;               reduce using rule 49 (has_stmt_expr -> stmt_expr .)


state 164

    (50) has_stmt_expr -> empty .

    )               reduce using rule 50 (has_stmt_expr -> empty .)
    ;               reduce using rule 50 (has_stmt_expr -> empty .)


state 165

    (38) stmt -> IF ( expr . ) stmt
    (39) stmt -> IF ( expr . ) stmt ELSE stmt
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    )               shift and go to state 178
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 166

    (84) assign -> lhs = expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ;               reduce using rule 84 (assign -> lhs = expr .)
    )               reduce using rule 84 (assign -> lhs = expr .)
    ]               reduce using rule 84 (assign -> lhs = expr .)
    ,               reduce using rule 84 (assign -> lhs = expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

  ! +               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! -               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! *               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! /               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! AND             [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! OR              [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! EQL             [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! UNEQL           [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! <               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! >               [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! LE              [ reduce using rule 84 (assign -> lhs = expr .) ]
  ! GE              [ reduce using rule 84 (assign -> lhs = expr .) ]

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 167

    (76) array_access -> primary [ expr ] .

    =               reduce using rule 76 (array_access -> primary [ expr ] .)
    INC             reduce using rule 76 (array_access -> primary [ expr ] .)
    DEC             reduce using rule 76 (array_access -> primary [ expr ] .)
    .               reduce using rule 76 (array_access -> primary [ expr ] .)
    [               reduce using rule 76 (array_access -> primary [ expr ] .)
    +               reduce using rule 76 (array_access -> primary [ expr ] .)
    -               reduce using rule 76 (array_access -> primary [ expr ] .)
    *               reduce using rule 76 (array_access -> primary [ expr ] .)
    /               reduce using rule 76 (array_access -> primary [ expr ] .)
    AND             reduce using rule 76 (array_access -> primary [ expr ] .)
    OR              reduce using rule 76 (array_access -> primary [ expr ] .)
    EQL             reduce using rule 76 (array_access -> primary [ expr ] .)
    UNEQL           reduce using rule 76 (array_access -> primary [ expr ] .)
    <               reduce using rule 76 (array_access -> primary [ expr ] .)
    >               reduce using rule 76 (array_access -> primary [ expr ] .)
    LE              reduce using rule 76 (array_access -> primary [ expr ] .)
    GE              reduce using rule 76 (array_access -> primary [ expr ] .)
    ;               reduce using rule 76 (array_access -> primary [ expr ] .)
    )               reduce using rule 76 (array_access -> primary [ expr ] .)
    ]               reduce using rule 76 (array_access -> primary [ expr ] .)
    ,               reduce using rule 76 (array_access -> primary [ expr ] .)


state 168

    (40) stmt -> WHILE ( expr ) . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (42) stmt -> . RETURN has_expr ;
    (43) stmt -> . stmt_expr ;
    (44) stmt -> . BREAK ;
    (45) stmt -> . CONTINUE ;
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (48) stmt -> . ;
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    IF              shift and go to state 88
    WHILE           shift and go to state 67
    FOR             shift and go to state 82
    RETURN          shift and go to state 70
    BREAK           shift and go to state 91
    CONTINUE        shift and go to state 92
    ;               shift and go to state 80
    {               shift and go to state 53
    INC             shift and go to state 97
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 86
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt                           shift and go to state 179
    stmt_expr                      shift and go to state 77
    array_access                   shift and go to state 72
    lhs                            shift and go to state 93
    var_decl                       shift and go to state 90
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 95
    block                          shift and go to state 96

state 169

    (65) primary -> NEW ID ( has_arguments . )

    )               shift and go to state 180


state 170

    (89) new_array -> new_array [ ] .

    [               reduce using rule 89 (new_array -> new_array [ ] .)
    ]               reduce using rule 89 (new_array -> new_array [ ] .)
    +               reduce using rule 89 (new_array -> new_array [ ] .)
    -               reduce using rule 89 (new_array -> new_array [ ] .)
    *               reduce using rule 89 (new_array -> new_array [ ] .)
    /               reduce using rule 89 (new_array -> new_array [ ] .)
    AND             reduce using rule 89 (new_array -> new_array [ ] .)
    OR              reduce using rule 89 (new_array -> new_array [ ] .)
    EQL             reduce using rule 89 (new_array -> new_array [ ] .)
    UNEQL           reduce using rule 89 (new_array -> new_array [ ] .)
    <               reduce using rule 89 (new_array -> new_array [ ] .)
    >               reduce using rule 89 (new_array -> new_array [ ] .)
    LE              reduce using rule 89 (new_array -> new_array [ ] .)
    GE              reduce using rule 89 (new_array -> new_array [ ] .)
    ;               reduce using rule 89 (new_array -> new_array [ ] .)
    )               reduce using rule 89 (new_array -> new_array [ ] .)
    ,               reduce using rule 89 (new_array -> new_array [ ] .)


state 171

    (92) new_array_temp -> NEW type [ . expr ]
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 181
    primary                        shift and go to state 105
    array_access                   shift and go to state 72
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    assign                         shift and go to state 119

state 172

    (91) new_array_temp -> new_array_temp [ expr . ]
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ]               shift and go to state 182
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 173

    (81) expr -> expr arith_op expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    ,               reduce using rule 81 (expr -> expr arith_op expr .)
    )               reduce using rule 81 (expr -> expr arith_op expr .)
    ]               reduce using rule 81 (expr -> expr arith_op expr .)
    ;               reduce using rule 81 (expr -> expr arith_op expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

  ! +               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! -               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! *               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! /               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! EQL             [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! UNEQL           [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! <               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! >               [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! LE              [ reduce using rule 81 (expr -> expr arith_op expr .) ]
  ! GE              [ reduce using rule 81 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 174

    (82) expr -> expr bool_op expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQL resolved as shift
  ! shift/reduce conflict for UNEQL resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    ,               reduce using rule 82 (expr -> expr bool_op expr .)
    )               reduce using rule 82 (expr -> expr bool_op expr .)
    ]               reduce using rule 82 (expr -> expr bool_op expr .)
    ;               reduce using rule 82 (expr -> expr bool_op expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

  ! +               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! -               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! *               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! /               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! EQL             [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! UNEQL           [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! <               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! >               [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! LE              [ reduce using rule 82 (expr -> expr bool_op expr .) ]
  ! GE              [ reduce using rule 82 (expr -> expr bool_op expr .) ]

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 175

    (77) method_invocation -> field_access ( has_arguments ) .

    .               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    [               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    )               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    +               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    -               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    *               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    /               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    AND             reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    OR              reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    EQL             reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    UNEQL           reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    <               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    >               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    LE              reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    GE              reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    ;               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    ,               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)
    ]               reduce using rule 77 (method_invocation -> field_access ( has_arguments ) .)


state 176

    (70) arguments -> arguments , . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 183
    primary                        shift and go to state 105
    literal                        shift and go to state 78
    lhs                            shift and go to state 118
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119
    unary_op                       shift and go to state 106

state 177

    (41) stmt -> FOR ( has_stmt_expr ; . has_expr ; has_stmt_expr ) stmt
    (51) has_expr -> . expr
    (52) has_expr -> . empty
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . new_array
    (81) expr -> . expr arith_op expr
    (82) expr -> . expr bool_op expr
    (83) expr -> . unary_op expr
    (110) empty -> .
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (89) new_array -> . new_array [ ]
    (90) new_array -> . new_array_temp
    (105) unary_op -> . +
    (106) unary_op -> . -
    (107) unary_op -> . !
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (77) method_invocation -> . field_access ( has_arguments )
    (91) new_array_temp -> . new_array_temp [ expr ]
    (92) new_array_temp -> . NEW type [ expr ]
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]

    ;               reduce using rule 110 (empty -> .)
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 107
    INC             shift and go to state 97
    DEC             shift and go to state 71
    +               shift and go to state 109
    -               shift and go to state 110
    !               shift and go to state 108
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89
    ID              shift and go to state 115

    new_array                      shift and go to state 104
    new_array_temp                 shift and go to state 114
    field_access                   shift and go to state 113
    expr                           shift and go to state 116
    literal                        shift and go to state 78
    primary                        shift and go to state 105
    has_expr                       shift and go to state 184
    lhs                            shift and go to state 118
    unary_op                       shift and go to state 106
    method_invocation              shift and go to state 111
    array_access                   shift and go to state 72
    assign                         shift and go to state 119
    empty                          shift and go to state 112

state 178

    (38) stmt -> IF ( expr ) . stmt
    (39) stmt -> IF ( expr ) . stmt ELSE stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (42) stmt -> . RETURN has_expr ;
    (43) stmt -> . stmt_expr ;
    (44) stmt -> . BREAK ;
    (45) stmt -> . CONTINUE ;
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (48) stmt -> . ;
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    IF              shift and go to state 88
    WHILE           shift and go to state 67
    FOR             shift and go to state 82
    RETURN          shift and go to state 70
    BREAK           shift and go to state 91
    CONTINUE        shift and go to state 92
    ;               shift and go to state 80
    {               shift and go to state 53
    INC             shift and go to state 97
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 86
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt                           shift and go to state 185
    stmt_expr                      shift and go to state 77
    array_access                   shift and go to state 72
    lhs                            shift and go to state 93
    var_decl                       shift and go to state 90
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 95
    block                          shift and go to state 96

state 179

    (40) stmt -> WHILE ( expr ) stmt .

    }               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    NEW             reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    INT_CONST       reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    NULL            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 40 (stmt -> WHILE ( expr ) stmt .)


state 180

    (65) primary -> NEW ID ( has_arguments ) .

    .               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    [               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    +               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    -               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    *               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    /               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    AND             reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    OR              reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    EQL             reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    UNEQL           reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    <               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    >               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    LE              reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    GE              reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    ;               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    )               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    ]               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)
    ,               reduce using rule 65 (primary -> NEW ID ( has_arguments ) .)


state 181

    (92) new_array_temp -> NEW type [ expr . ]
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ]               shift and go to state 186
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 182

    (91) new_array_temp -> new_array_temp [ expr ] .

    [               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    )               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    +               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    -               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    *               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    /               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    AND             reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    OR              reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    EQL             reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    UNEQL           reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    <               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    >               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    LE              reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    GE              reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    ]               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    ,               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)
    ;               reduce using rule 91 (new_array_temp -> new_array_temp [ expr ] .)


state 183

    (70) arguments -> arguments , expr .
    (81) expr -> expr . arith_op expr
    (82) expr -> expr . bool_op expr
    (93) arith_op -> . +
    (94) arith_op -> . -
    (95) arith_op -> . *
    (96) arith_op -> . /
    (97) bool_op -> . AND
    (98) bool_op -> . OR
    (99) bool_op -> . EQL
    (100) bool_op -> . UNEQL
    (101) bool_op -> . <
    (102) bool_op -> . >
    (103) bool_op -> . LE
    (104) bool_op -> . GE

    ,               reduce using rule 70 (arguments -> arguments , expr .)
    )               reduce using rule 70 (arguments -> arguments , expr .)
    +               shift and go to state 145
    -               shift and go to state 147
    *               shift and go to state 146
    /               shift and go to state 148
    AND             shift and go to state 143
    OR              shift and go to state 154
    EQL             shift and go to state 153
    UNEQL           shift and go to state 150
    <               shift and go to state 149
    >               shift and go to state 155
    LE              shift and go to state 144
    GE              shift and go to state 152

    arith_op                       shift and go to state 142
    bool_op                        shift and go to state 151

state 184

    (41) stmt -> FOR ( has_stmt_expr ; has_expr . ; has_stmt_expr ) stmt

    ;               shift and go to state 187


state 185

    (38) stmt -> IF ( expr ) stmt .
    (39) stmt -> IF ( expr ) stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    }               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    BOOLEAN         reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    (               reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    INT_CONST       reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    STRING_CONST    reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    NULL            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 38 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 188

  ! ELSE            [ reduce using rule 38 (stmt -> IF ( expr ) stmt .) ]


state 186

    (92) new_array_temp -> NEW type [ expr ] .

    [               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    )               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    +               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    -               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    *               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    /               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    AND             reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    OR              reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    EQL             reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    UNEQL           reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    <               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    >               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    LE              reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    GE              reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    ]               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    ,               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)
    ;               reduce using rule 92 (new_array_temp -> NEW type [ expr ] .)


state 187

    (41) stmt -> FOR ( has_stmt_expr ; has_expr ; . has_stmt_expr ) stmt
    (49) has_stmt_expr -> . stmt_expr
    (50) has_stmt_expr -> . empty
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (110) empty -> .
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    )               reduce using rule 110 (empty -> .)
    INC             shift and go to state 97
    DEC             shift and go to state 71
    ID              shift and go to state 115
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    has_stmt_expr                  shift and go to state 189
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt_expr                      shift and go to state 163
    lhs                            shift and go to state 93
    method_invocation              shift and go to state 79
    array_access                   shift and go to state 72
    assign                         shift and go to state 95
    empty                          shift and go to state 164

state 188

    (39) stmt -> IF ( expr ) stmt ELSE . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (42) stmt -> . RETURN has_expr ;
    (43) stmt -> . stmt_expr ;
    (44) stmt -> . BREAK ;
    (45) stmt -> . CONTINUE ;
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (48) stmt -> . ;
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    IF              shift and go to state 88
    WHILE           shift and go to state 67
    FOR             shift and go to state 82
    RETURN          shift and go to state 70
    BREAK           shift and go to state 91
    CONTINUE        shift and go to state 92
    ;               shift and go to state 80
    {               shift and go to state 53
    INC             shift and go to state 97
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 86
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt                           shift and go to state 190
    stmt_expr                      shift and go to state 77
    array_access                   shift and go to state 72
    lhs                            shift and go to state 93
    var_decl                       shift and go to state 90
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 95
    block                          shift and go to state 96

state 189

    (41) stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr . ) stmt

    )               shift and go to state 191


state 190

    (39) stmt -> IF ( expr ) stmt ELSE stmt .

    }               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_CONST       reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_CONST    reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NULL            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 39 (stmt -> IF ( expr ) stmt ELSE stmt .)


state 191

    (41) stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) . stmt
    (38) stmt -> . IF ( expr ) stmt
    (39) stmt -> . IF ( expr ) stmt ELSE stmt
    (40) stmt -> . WHILE ( expr ) stmt
    (41) stmt -> . FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt
    (42) stmt -> . RETURN has_expr ;
    (43) stmt -> . stmt_expr ;
    (44) stmt -> . BREAK ;
    (45) stmt -> . CONTINUE ;
    (46) stmt -> . block
    (47) stmt -> . var_decl
    (48) stmt -> . ;
    (108) stmt_expr -> . assign
    (109) stmt_expr -> . method_invocation
    (35) block -> . { stmts }
    (17) var_decl -> . type variables
    (84) assign -> . lhs = expr
    (85) assign -> . lhs INC
    (86) assign -> . INC lhs
    (87) assign -> . lhs DEC
    (88) assign -> . DEC lhs
    (77) method_invocation -> . field_access ( has_arguments )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (72) lhs -> . field_access
    (73) lhs -> . array_access
    (74) field_access -> . primary . ID
    (75) field_access -> . ID
    (76) array_access -> . primary [ expr ]
    (61) primary -> . literal
    (62) primary -> . THIS
    (63) primary -> . SUPER
    (64) primary -> . ( expr )
    (65) primary -> . NEW ID ( has_arguments )
    (66) primary -> . lhs
    (67) primary -> . method_invocation
    (55) literal -> . INT_CONST
    (56) literal -> . FLOAT_CONST
    (57) literal -> . STRING_CONST
    (58) literal -> . NULL
    (59) literal -> . TRUE
    (60) literal -> . FALSE

    IF              shift and go to state 88
    WHILE           shift and go to state 67
    FOR             shift and go to state 82
    RETURN          shift and go to state 70
    BREAK           shift and go to state 91
    CONTINUE        shift and go to state 92
    ;               shift and go to state 80
    {               shift and go to state 53
    INC             shift and go to state 97
    DEC             shift and go to state 71
    INT             shift and go to state 26
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 86
    THIS            shift and go to state 85
    SUPER           shift and go to state 83
    (               shift and go to state 76
    NEW             shift and go to state 69
    INT_CONST       shift and go to state 74
    FLOAT_CONST     shift and go to state 68
    STRING_CONST    shift and go to state 73
    NULL            shift and go to state 75
    TRUE            shift and go to state 87
    FALSE           shift and go to state 89

    field_access                   shift and go to state 81
    literal                        shift and go to state 78
    primary                        shift and go to state 66
    stmt                           shift and go to state 192
    stmt_expr                      shift and go to state 77
    array_access                   shift and go to state 72
    lhs                            shift and go to state 93
    var_decl                       shift and go to state 90
    method_invocation              shift and go to state 79
    type                           shift and go to state 28
    assign                         shift and go to state 95
    block                          shift and go to state 96

state 192

    (41) stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .

    }               reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    IF              reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    WHILE           reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    FOR             reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    RETURN          reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    BREAK           reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    CONTINUE        reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    ;               reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    {               reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    INC             reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    DEC             reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    INT             reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    FLOAT           reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    ID              reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    THIS            reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    SUPER           reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    (               reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    NEW             reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    INT_CONST       reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    NULL            reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    TRUE            reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    FALSE           reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)
    ELSE            reduce using rule 41 (stmt -> FOR ( has_stmt_expr ; has_expr ; has_stmt_expr ) stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for [ in state 114 resolved as shift
WARNING: shift/reduce conflict for + in state 138 resolved as shift
WARNING: shift/reduce conflict for - in state 138 resolved as shift
WARNING: shift/reduce conflict for * in state 138 resolved as shift
WARNING: shift/reduce conflict for / in state 138 resolved as shift
WARNING: shift/reduce conflict for AND in state 138 resolved as shift
WARNING: shift/reduce conflict for OR in state 138 resolved as shift
WARNING: shift/reduce conflict for EQL in state 138 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 138 resolved as shift
WARNING: shift/reduce conflict for < in state 138 resolved as shift
WARNING: shift/reduce conflict for > in state 138 resolved as shift
WARNING: shift/reduce conflict for LE in state 138 resolved as shift
WARNING: shift/reduce conflict for GE in state 138 resolved as shift
WARNING: shift/reduce conflict for + in state 173 resolved as shift
WARNING: shift/reduce conflict for - in state 173 resolved as shift
WARNING: shift/reduce conflict for * in state 173 resolved as shift
WARNING: shift/reduce conflict for / in state 173 resolved as shift
WARNING: shift/reduce conflict for AND in state 173 resolved as shift
WARNING: shift/reduce conflict for OR in state 173 resolved as shift
WARNING: shift/reduce conflict for EQL in state 173 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 173 resolved as shift
WARNING: shift/reduce conflict for < in state 173 resolved as shift
WARNING: shift/reduce conflict for > in state 173 resolved as shift
WARNING: shift/reduce conflict for LE in state 173 resolved as shift
WARNING: shift/reduce conflict for GE in state 173 resolved as shift
WARNING: shift/reduce conflict for + in state 174 resolved as shift
WARNING: shift/reduce conflict for - in state 174 resolved as shift
WARNING: shift/reduce conflict for * in state 174 resolved as shift
WARNING: shift/reduce conflict for / in state 174 resolved as shift
WARNING: shift/reduce conflict for AND in state 174 resolved as shift
WARNING: shift/reduce conflict for OR in state 174 resolved as shift
WARNING: shift/reduce conflict for EQL in state 174 resolved as shift
WARNING: shift/reduce conflict for UNEQL in state 174 resolved as shift
WARNING: shift/reduce conflict for < in state 174 resolved as shift
WARNING: shift/reduce conflict for > in state 174 resolved as shift
WARNING: shift/reduce conflict for LE in state 174 resolved as shift
WARNING: shift/reduce conflict for GE in state 174 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 185 resolved as shift
